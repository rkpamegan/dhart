<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DHART: ViewAnalysis</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome-css.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DHART
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('a00459.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ViewAnalysis</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga6ca336e3887ef82d17b0713c2bf862df"><td class="memItemLeft" align="right" valign="top">vector&lt; std::array&lt; float, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00459.html#ga6ca336e3887ef82d17b0713c2bf862df">HF::ViewAnalysis::FibbonacciDistributePoints</a> (int num_points, float upwards_fov=50.0f, float downward_fov=70.0f)</td></tr>
<tr class="memdesc:ga6ca336e3887ef82d17b0713c2bf862df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evenly distribute a set of points around a sphere centered at the origin.   <a href="a00459.html#ga6ca336e3887ef82d17b0713c2bf862df">More...</a><br /></td></tr>
<tr class="separator:ga6ca336e3887ef82d17b0713c2bf862df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecaa04882696ac6d73173227bd28e91b"><td class="memTemplParams" colspan="2">template&lt;typename RES , typename RT , typename N &gt; </td></tr>
<tr class="memitem:gaecaa04882696ac6d73173227bd28e91b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; RES &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00459.html#gaecaa04882696ac6d73173227bd28e91b">HF::ViewAnalysis::SphericalViewAnalysis</a> (RT &amp;ray_tracer, const std::vector&lt; N &gt; &amp;Nodes, int num_rays, float upward_limit=50.0f, float downward_limit=70.0f, float height=1.7f)</td></tr>
<tr class="memdesc:gaecaa04882696ac6d73173227bd28e91b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conduct view analysis with any Raytracer in parallel.   <a href="a00459.html#gaecaa04882696ac6d73173227bd28e91b">More...</a><br /></td></tr>
<tr class="separator:gaecaa04882696ac6d73173227bd28e91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78f77d24531d0fa55c9b60d7ec1bf32a"><td class="memTemplParams" colspan="2">template&lt;typename RT , typename N &gt; </td></tr>
<tr class="memitem:ga78f77d24531d0fa55c9b60d7ec1bf32a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00459.html#ga78f77d24531d0fa55c9b60d7ec1bf32a">HF::ViewAnalysis::SphericalRayshootWithAnyRTForDistance</a> (RT &amp;ray_tracer, const std::vector&lt; N &gt; &amp;Nodes, int num_rays, float upward_limit=50.0f, float downward_limit=70.0f, float height=1.7f, const <a class="el" href="a00466.html#a1fcaa17d2a8df8896a3b0447973bd07b">AGGREGATE_TYPE</a> aggregation=<a class="el" href="a00466.html#a1fcaa17d2a8df8896a3b0447973bd07ba6970bdc2201030b9c03fbdcf3973858a">AGGREGATE_TYPE::SUM</a>)</td></tr>
<tr class="memdesc:ga78f77d24531d0fa55c9b60d7ec1bf32a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conduct view analysis and recieve a summarized set of results for each node.   <a href="a00459.html#ga78f77d24531d0fa55c9b60d7ec1bf32a">More...</a><br /></td></tr>
<tr class="separator:ga78f77d24531d0fa55c9b60d7ec1bf32a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6b8e3eab649b42ac014fb7d02d54892"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00407.html#a91fa3b2bb3a7312ec39d74cc1fbc7bbe">C_INTERFACE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00459.html#gab6b8e3eab649b42ac014fb7d02d54892">SphereicalViewAnalysisAggregate</a> (<a class="el" href="a01411.html">HF::RayTracer::EmbreeRayTracer</a> *ERT, <a class="el" href="a02071.html">HF::SpatialStructures::Node</a> *node_ptr, int node_size, int max_rays, float upward_fov, float downward_fov, float height, <a class="el" href="a00443.html#a8a1aa9474094ff70818051c921c0537f">AGGREGATE_TYPE</a> AT, std::vector&lt; float &gt; **out_scores, float **out_scores_ptr, int *out_scores_size)</td></tr>
<tr class="memdesc:gab6b8e3eab649b42ac014fb7d02d54892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conduct view analysis, then aggregate the results.  <a href="a00459.html#gab6b8e3eab649b42ac014fb7d02d54892">More...</a><br /></td></tr>
<tr class="separator:gab6b8e3eab649b42ac014fb7d02d54892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4c5714c1e557ef83a03d447eb30c6d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00407.html#a91fa3b2bb3a7312ec39d74cc1fbc7bbe">C_INTERFACE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00459.html#gaa4c5714c1e557ef83a03d447eb30c6d0">SphereicalViewAnalysisAggregateFlat</a> (<a class="el" href="a01411.html">HF::RayTracer::EmbreeRayTracer</a> *ERT, const float *node_ptr, int node_size, int max_rays, float upward_fov, float downward_fov, float height, <a class="el" href="a00443.html#a8a1aa9474094ff70818051c921c0537f">AGGREGATE_TYPE</a> AT, std::vector&lt; float &gt; **out_scores, float **out_scores_ptr, int *out_scores_size)</td></tr>
<tr class="memdesc:gaa4c5714c1e557ef83a03d447eb30c6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conduct view analysis, and aggregate the results.  <a href="a00459.html#gaa4c5714c1e557ef83a03d447eb30c6d0">More...</a><br /></td></tr>
<tr class="separator:gaa4c5714c1e557ef83a03d447eb30c6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94d3ddc3981020e2852fc77e51266185"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00407.html#a91fa3b2bb3a7312ec39d74cc1fbc7bbe">C_INTERFACE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00459.html#ga94d3ddc3981020e2852fc77e51266185">SphericalViewAnalysisNoAggregate</a> (<a class="el" href="a01411.html">HF::RayTracer::EmbreeRayTracer</a> *ERT, const <a class="el" href="a02071.html">HF::SpatialStructures::Node</a> *node_ptr, int node_size, int *max_rays, float upward_fov, float downward_fov, float height, std::vector&lt; <a class="el" href="a02087.html">RayResult</a> &gt; **out_results, <a class="el" href="a02087.html">RayResult</a> **out_results_ptr)</td></tr>
<tr class="memdesc:ga94d3ddc3981020e2852fc77e51266185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform view analysis, then get the distance and meshid for each individual ray casted.  <a href="a00459.html#ga94d3ddc3981020e2852fc77e51266185">More...</a><br /></td></tr>
<tr class="separator:ga94d3ddc3981020e2852fc77e51266185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga348af4492f3e4e7ffab6da3e86de3924"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00407.html#a91fa3b2bb3a7312ec39d74cc1fbc7bbe">C_INTERFACE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00459.html#ga348af4492f3e4e7ffab6da3e86de3924">SphericalViewAnalysisNoAggregateFlat</a> (<a class="el" href="a01411.html">HF::RayTracer::EmbreeRayTracer</a> *ERT, const float *node_ptr, int node_size, int *max_rays, float upward_fov, float downward_fov, float height, std::vector&lt; <a class="el" href="a02087.html">RayResult</a> &gt; **out_results, <a class="el" href="a02087.html">RayResult</a> **out_results_ptr)</td></tr>
<tr class="memdesc:ga348af4492f3e4e7ffab6da3e86de3924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform view analysis, and get the distance and meshid for each individual ray casted.  <a href="a00459.html#ga348af4492f3e4e7ffab6da3e86de3924">More...</a><br /></td></tr>
<tr class="separator:ga348af4492f3e4e7ffab6da3e86de3924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf572b7bec28d55bf2c72719742703dff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00407.html#a91fa3b2bb3a7312ec39d74cc1fbc7bbe">C_INTERFACE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00459.html#gaf572b7bec28d55bf2c72719742703dff">SphericalDistribute</a> (int *num_rays, std::vector&lt; float &gt; **out_direction_vector, float **out_direction_data, float upward_fov, float downward_fov)</td></tr>
<tr class="memdesc:gaf572b7bec28d55bf2c72719742703dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equally distribute points around a unit sphere.  <a href="a00459.html#gaf572b7bec28d55bf2c72719742703dff">More...</a><br /></td></tr>
<tr class="separator:gaf572b7bec28d55bf2c72719742703dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Analyze the view from points in the environment. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga6ca336e3887ef82d17b0713c2bf862df" name="ga6ca336e3887ef82d17b0713c2bf862df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ca336e3887ef82d17b0713c2bf862df">&#9670;&#160;</a></span>FibbonacciDistributePoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::array&lt; float, 3 &gt; &gt; HF::ViewAnalysis::FibbonacciDistributePoints </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>upwards_fov</em> = <code>50.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>downward_fov</em> = <code>70.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="a00020.html">Cpp/analysismethods/src/view_analysis.cpp</a>&gt;</code></p>

<p>Evenly distribute a set of points around a sphere centered at the origin.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_points</td><td>Maximum number of points to distribute. </td></tr>
    <tr><td class="paramname">upward_limit</td><td>Maximum angle in degrees to cast rays above the viewpoint. </td></tr>
    <tr><td class="paramname">downward_limit</td><td>Maximum angle in degrees to cast rays below the viewpoint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of arrays containing the x, y, and z coordinates of each point on the sphere.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The number of points returned by this function will not exactly equal the amount of points specified by num_points depending on the values of upwards_fov and downward fov. More information is available below.</dd></dl>
<dl class="section user"><dt>How FOV is implemented</dt><dd>Every point is equally distributed on a sphere using a formula based on this stack overflow answer: <a href="https://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere">https://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere</a>. This formula cannot easily be mapped to a specific vertical fov or cone, so instead this function will remove points that don't meet the constraints. Discarding points causes the number of points generated to be less than the num_rays argument, so the percentage of points discarded is calculated and a second run is performed with an adjusted num_rays value to get as close as possible to the value specified in the argument. This approach will not result in an exact match to the num_rays argument, and will run <a class="el" href="a00466.html#a5b45790c767b670bc00bf3fd2335159a">FibbonacciDist</a> twice.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="comment">// Requires #include &quot;view_analysis.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// For brevity</span></div>
<div class="line"><span class="keyword">using </span><a class="code hl_function" href="a00459.html#ga6ca336e3887ef82d17b0713c2bf862df">HF::ViewAnalysis::FibbonacciDistributePoints</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Prepare maximum number of points to distribute</span></div>
<div class="line"><span class="keywordtype">int</span> size = 8;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Generate points without any limitations on fov</span></div>
<div class="line"><span class="keyword">auto</span> points = <a class="code hl_function" href="a00459.html#ga6ca336e3887ef82d17b0713c2bf862df">FibbonacciDistributePoints</a>(size, 90.0f, 90.0f);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Print number of points</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Number of Points:&quot;</span> &lt;&lt; points.size() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Iterate through results and print every point.</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span>;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; size; i++) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; point =  points[i];</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; point[0] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; point[1] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; point[2] &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (i != size - 1) std::cout &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">}</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; std::endl;</div>
<div class="ttc" id="aa00459_html_ga6ca336e3887ef82d17b0713c2bf862df"><div class="ttname"><a href="a00459.html#ga6ca336e3887ef82d17b0713c2bf862df">HF::ViewAnalysis::FibbonacciDistributePoints</a></div><div class="ttdeci">vector&lt; std::array&lt; float, 3 &gt; &gt; FibbonacciDistributePoints(int num_points, float upwards_fov, float downward_fov)</div><div class="ttdoc">Evenly distribute a set of points around a sphere centered at the origin.</div><div class="ttdef"><b>Definition:</b> <a href="a00020_source.html#l00121">view_analysis.cpp:121</a></div></div>
</div><!-- fragment --></dd></dl>
<p><code>&gt;&gt;&gt; Number of Points:8</code><br  />
<code>&gt;&gt;&gt; [(-0, -1, 0), (-0.304862, -0.75, -0.586992), (0.813476, -0.5, 0.29708), (-0.894994, -0.25, 0.369441),</code> <code>(0.423846, 0, -0.905734), (0.289781, 0.25, 0.923865), (-0.749296, 0.5, -0.43423), (0.64601, 0.75, -0.142025)]</code> </p>

<p class="definition">Definition at line <a class="el" href="a00020_source.html#l00121">121</a> of file <a class="el" href="a00020_source.html">view_analysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00020_source.html#l00084">HF::ViewAnalysis::FibbonacciDist()</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00440_source.html#l00126">SphericalDistribute()</a>, <a class="el" href="a00023_source.html#l00484">HF::ViewAnalysis::SphericalRayshootWithAnyRTForDistance()</a>, and <a class="el" href="a00023_source.html#l00335">HF::ViewAnalysis::SphericalViewAnalysis()</a>.</p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00459_ga6ca336e3887ef82d17b0713c2bf862df_cgraph.svg" width="719" height="171"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00459_ga6ca336e3887ef82d17b0713c2bf862df_icgraph.svg" width="762" height="171"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="gab6b8e3eab649b42ac014fb7d02d54892" name="gab6b8e3eab649b42ac014fb7d02d54892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6b8e3eab649b42ac014fb7d02d54892">&#9670;&#160;</a></span>SphereicalViewAnalysisAggregate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00407.html#a91fa3b2bb3a7312ec39d74cc1fbc7bbe">C_INTERFACE</a> SphereicalViewAnalysisAggregate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01411.html">HF::RayTracer::EmbreeRayTracer</a> *&#160;</td>
          <td class="paramname"><em>ERT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02071.html">HF::SpatialStructures::Node</a> *&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_rays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>upward_fov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>downward_fov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00443.html#a8a1aa9474094ff70818051c921c0537f">AGGREGATE_TYPE</a>&#160;</td>
          <td class="paramname"><em>AT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; **&#160;</td>
          <td class="paramname"><em>out_scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname"><em>out_scores_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>out_scores_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="a00443.html">Cinterface/view_analysis_C.h</a>&gt;</code></p>

<p>Conduct view analysis, then aggregate the results. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ERT</td><td>Raytracer containing the geometry to use for ray intersections. </td></tr>
    <tr><td class="paramname">node_ptr</td><td>Observer points for the view analysis. </td></tr>
    <tr><td class="paramname">node_size</td><td>Number of nodes in the array pointed to by node_ptr.</td></tr>
    <tr><td class="paramname">max_rays</td><td>Number of rays to cast for each node in node_ptr. Note that this may cast fewer rays than max_rays, depending on FOV restrictions.</td></tr>
    <tr><td class="paramname">upward_fov</td><td>Maximum degrees upward from the viewer's eye level to consider. </td></tr>
    <tr><td class="paramname">downward_fov</td><td>Maximum degrees downward from the viewer's eye level to consider. </td></tr>
    <tr><td class="paramname">height</td><td>Height to offset nodes from the ground (+Z direction). </td></tr>
    <tr><td class="paramname">AT</td><td>Type of aggregation method to use. </td></tr>
    <tr><td class="paramname">out_scores</td><td>Output parameter for node scores. </td></tr>
    <tr><td class="paramname">out_scores_ptr</td><td>Pointer to the data of out_scores. </td></tr>
    <tr><td class="paramname">out_scores_size</td><td>Size of output_scores_ptr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HF::Status::OK on completion.</dd></dl>
<dl class="section user"><dt>Caller's Responsibility</dt><dd>The caller must call <a class="el" href="a00410.html#af77723a4383b278169e80cf0e361ec44">DestroyFloatVector</a> with out_scores to free the memory allocated by this function.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) ERT points to a valid raytracer created by CreateRaytracer </dd>
<dd>
2) node_ptr contains a valid array of nodes with length equal to node_size </dd>
<dd>
3) out_scores, out_scores_ptr, and out_score_size are not null</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>1) out_scores contains a pointer to score for every node in nodes in order </dd>
<dd>
2) out_scores_ptr cpoints to a valid array of scores </dd>
<dd>
3) out_scores_size is updated to the length of the data held by out_scores_ptr</dd></dl>
<dl class="todo"><dt><b><a class="el" href="a00452.html#_todo000031">Todo:</a></b></dt><dd>Is there any situation where out_scores_size is smaller than node_size?</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00455.html#mesh_setup">Mesh setup</a> (how to create a mesh), <a class="el" href="a00455.html#mesh_teardown">Mesh teardown</a> (how to destroy a mesh) </dd>
<dd>
<a class="el" href="a00457.html#raytracer_setup">Raytracer setup</a> (how to create a BVH), <a class="el" href="a00457.html#raytracer_teardown">Raytracer teardown</a> (how to destroy a BVH)</dd>
<dd>
<a class="el" href="">SphericalViewAnalysis</a> for an algorithm that returns the results of every ray casted instead of aggregating the results.</dd>
<dd>
<a class="el" href="">SphericalViewAnalysisAggregateFlat</a> for a function that works on a flat array of floats instead of an array of nodes.</dd></dl>
<p>Begin by <b>loading an .obj file</b> (<a class="el" href="a00455.html#mesh_setup">Mesh setup</a>).<br  />
 Then, <b>create a BVH</b> (<a class="el" href="a00457.html#raytracer_setup">Raytracer setup</a>) using the <b>mesh</b>.<br  />
</p>
<dl class="section user"><dt>Example Code</dt><dd></dd></dl>
<p>Set up the parameters for the view analysis. </p><div class="fragment"><div class="line">        <span class="comment">// Preparing the parameters for SphereicalViewAnalysisAggregate</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Define point to start ray</span></div>
<div class="line">        <span class="comment">// These are Cartesian coordinates.</span></div>
<div class="line">        std::array&lt;Node, 3&gt; p1{ Node(0.0f, 0.0f, 2.0f) };</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Define direction to cast ray</span></div>
<div class="line">        <span class="comment">// These are vector components, not Cartesian coordinates.</span></div>
<div class="line">        std::array&lt;float, 3&gt; dir { 0.0f, 0.0f, -1.0f };</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// This is a container of nodes to be analyzed.</span></div>
<div class="line">        <span class="comment">// SphereicalViewAnalysisAggregate accepts a (Node *) parameter,</span></div>
<div class="line">        <span class="comment">// so a raw stack-allocated array will suffice.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// This may also be a pointer to a heap-allocated buffer</span></div>
<div class="line">        <span class="comment">// (which is owned by a vector&lt;Node&gt;, accessed via the vector&lt;Node&gt;::data() method).</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// ...or, it can be a pointer to memory allocated by the caller via operator new[node_count]</span></div>
<div class="line">        <span class="comment">// (if this route is taken, be sure to release the memory with operator delete[] after use)</span></div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> node_count = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(p1.size()); <span class="comment">// should be the element count in nodes</span></div>
<div class="line">        <span class="keywordtype">int</span> ray_count = 1000;               <span class="comment">// will be mutated by SphereicalViewAnalysisAggregate</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> height = 1.7f;          <span class="comment">// height to offset nodes from the ground, in meters</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> upward_fov = 50.0f;     <span class="comment">// default parameter is 50.0f in Python code</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> downward_fov = 70.0f;   <span class="comment">// default parameter is 70.0f in Python code</span></div>
</div><!-- fragment --><p >Now you must prepare a pointer to a std::vector&lt;float&gt;, where the <b>aggregation results</b> will be stored.<br  />
 You must also select the aggregate type. </p><div class="fragment"><div class="line">        <span class="comment">// Declare a pointer to vector&lt;float&gt;, named aggregate_results.</span></div>
<div class="line">        <span class="comment">// This pointer will point to memory on the free store,</span></div>
<div class="line">        <span class="comment">// allocated within SphereicalViewAnalysisAggregate.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// aggregate_results_data will point to the underlying buffer within *aggregate_results,</span></div>
<div class="line">        <span class="comment">// which will be assigned inside SphereicalViewAnalysisAggregate.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Note that we must call operator delete on aggregate_results when we are finished with it.</span></div>
<div class="line">        std::vector&lt;float&gt;* aggregate_results = <span class="keyword">nullptr</span>;</div>
<div class="line">        <span class="keywordtype">float</span>* aggregate_results_data = <span class="keyword">nullptr</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Will be equal to aggregate_results-&gt;size();</span></div>
<div class="line">        <span class="keywordtype">int</span> aggregate_results_size = -1;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Select the aggregate type.</span></div>
<div class="line">        <span class="comment">// This determines how to aggregate the edges within the results of the view analysis.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// AGGREGATE_TYPE::AVERAGE means that the edges will be aggregated</span></div>
<div class="line">        <span class="comment">// by the maximum distance from the origin point to its hit points.</span></div>
<div class="line">        <a class="code hl_enumeration" href="a00443.html#a8a1aa9474094ff70818051c921c0537f">AGGREGATE_TYPE</a> agg_type = <a class="code hl_enumvalue" href="a00443.html#a8a1aa9474094ff70818051c921c0537fa16de38737a9f8366e9b2042b4e9b6290">AGGREGATE_TYPE::AVERAGE</a>;</div>
<div class="ttc" id="aa00443_html_a8a1aa9474094ff70818051c921c0537f"><div class="ttname"><a href="a00443.html#a8a1aa9474094ff70818051c921c0537f">AGGREGATE_TYPE</a></div><div class="ttdeci">AGGREGATE_TYPE</div><div class="ttdoc">Determines how to aggregate edges from the results of view analysis.</div><div class="ttdef"><b>Definition:</b> <a href="a00443_source.html#l00033">view_analysis_C.h:33</a></div></div>
<div class="ttc" id="aa00443_html_a8a1aa9474094ff70818051c921c0537fa16de38737a9f8366e9b2042b4e9b6290"><div class="ttname"><a href="a00443.html#a8a1aa9474094ff70818051c921c0537fa16de38737a9f8366e9b2042b4e9b6290">AGGREGATE_TYPE::AVERAGE</a></div><div class="ttdeci">@ AVERAGE</div><div class="ttdoc">Average distance of origin to its hit points.</div></div>
</div><!-- fragment --><p >Now we are ready to call <a class="el" href="a00459.html#gab6b8e3eab649b42ac014fb7d02d54892">SphereicalViewAnalysisAggregate</a> . </p><div class="fragment"><div class="line">        status = <a class="code hl_function" href="a00459.html#gab6b8e3eab649b42ac014fb7d02d54892">SphereicalViewAnalysisAggregate</a>(bvh,</div>
<div class="line">            p1.data(), node_count, ray_count,</div>
<div class="line">            upward_fov, downward_fov, height,</div>
<div class="line">            agg_type,</div>
<div class="line">            &amp;aggregate_results, &amp;aggregate_results_data, &amp;aggregate_results_size);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (status != 1) {</div>
<div class="line">            <span class="comment">// Error!</span></div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error at SphereicalViewAnalysisAggregate, code: &quot;</span> &lt;&lt; status &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="ttc" id="aa00459_html_gab6b8e3eab649b42ac014fb7d02d54892"><div class="ttname"><a href="a00459.html#gab6b8e3eab649b42ac014fb7d02d54892">SphereicalViewAnalysisAggregate</a></div><div class="ttdeci">C_INTERFACE SphereicalViewAnalysisAggregate(EmbreeRayTracer *ERT, Node *node_ptr, int node_size, int max_rays, float upward_fov, float downward_fov, float height, AGGREGATE_TYPE AT, vector&lt; float &gt; **out_scores, float **out_scores_ptr, int *out_scores_size)</div><div class="ttdoc">Conduct view analysis, then aggregate the results.</div><div class="ttdef"><b>Definition:</b> <a href="a00440_source.html#l00017">view_analysis_C.cpp:17</a></div></div>
</div><!-- fragment --><p >We can output the contents of the <b>aggregate results vector</b> to <b>stdout</b> . </p><div class="fragment"><div class="line">        <span class="comment">// Print aggregate results vector (vector&lt;float&gt;)</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span>;</div>
<div class="line">        <span class="keywordtype">int</span> i = 0;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> agg_result : *aggregate_results) {</div>
<div class="line">            std::cout &lt;&lt; agg_result;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (i &lt; aggregate_results-&gt;size() - 1) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            ++i;</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --><p >After using the view analysis results, its resources must be <b>relinquished</b> . </p><div class="fragment"><div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Memory resource cleanup.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// destroy vector&lt;float&gt;</span></div>
<div class="line">        <span class="keywordflow">if</span> (aggregate_results) {</div>
<div class="line">            <span class="keyword">delete</span> aggregate_results;</div>
<div class="line">        }</div>
</div><!-- fragment --><p >From here, please review the example at <a class="el" href="a00457.html#raytracer_teardown">Raytracer teardown</a> for instructions<br  />
 on how to free the remainder of the resources used for the view analysis &ndash;<br  />
 which are the (vector&lt;<a class="el" href="a01351.html">HF::Geometry::MeshInfo</a>&gt; *) and (<a class="el" href="">HF::Raytracer::EmbreeRayTracer</a> *) instances.</p>
<p ><code>&gt;&gt;&gt; LoadOBJ loaded mesh successfully into loaded_obj at address 00000293CC9C8650, code: 1</code><br  />
<code>&gt;&gt;&gt; CreateRaytracer created EmbreeRayTracer successfully into bvh at address 00000293C3012D20, code: 1</code><br  />
<code>&gt;&gt;&gt; [7.43102, 0, 0]</code><br  />
</p>

<p class="definition">Definition at line <a class="el" href="a00440_source.html#l00017">17</a> of file <a class="el" href="a00440_source.html">view_analysis_C.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00176_source.html#l00032">HF::Exceptions::OK</a>, and <a class="el" href="a00023_source.html#l00484">HF::ViewAnalysis::SphericalRayshootWithAnyRTForDistance()</a>.</p>
<div id="dynsection-2" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-2-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00459_gab6b8e3eab649b42ac014fb7d02d54892_cgraph.svg" width="1251" height="171"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="gaa4c5714c1e557ef83a03d447eb30c6d0" name="gaa4c5714c1e557ef83a03d447eb30c6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4c5714c1e557ef83a03d447eb30c6d0">&#9670;&#160;</a></span>SphereicalViewAnalysisAggregateFlat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00407.html#a91fa3b2bb3a7312ec39d74cc1fbc7bbe">C_INTERFACE</a> SphereicalViewAnalysisAggregateFlat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01411.html">HF::RayTracer::EmbreeRayTracer</a> *&#160;</td>
          <td class="paramname"><em>ERT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_rays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>upward_fov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>downward_fov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00443.html#a8a1aa9474094ff70818051c921c0537f">AGGREGATE_TYPE</a>&#160;</td>
          <td class="paramname"><em>AT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; **&#160;</td>
          <td class="paramname"><em>out_scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname"><em>out_scores_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>out_scores_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="a00443.html">Cinterface/view_analysis_C.h</a>&gt;</code></p>

<p>Conduct view analysis, and aggregate the results. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ERT</td><td>Raytracer containing the geometry to use for ray intersections. </td></tr>
    <tr><td class="paramname">node_ptr</td><td>Observer points for the view analysis. Each 3 floats represent the {x, y, z} of a new node. </td></tr>
    <tr><td class="paramname">node_size</td><td>Number of nodes in the array pointed to by node_ptr.</td></tr>
    <tr><td class="paramname">max_rays</td><td>Number of rays to cast for each node in node_ptr. Note that this may cast fewer rays than max_rays depending on fov restrictions.</td></tr>
    <tr><td class="paramname">upward_fov</td><td>Maximum degrees upward from the viewer's eye level to consider. </td></tr>
    <tr><td class="paramname">downward_fov</td><td>Maximum degrees downward from the viewer's eye level to consider. </td></tr>
    <tr><td class="paramname">height</td><td>Height to offset nodes from the ground (+Z direction). </td></tr>
    <tr><td class="paramname">AT</td><td>Type of aggregation method to use. </td></tr>
    <tr><td class="paramname">out_scores</td><td>Output parameter for node scores. </td></tr>
    <tr><td class="paramname">out_scores_ptr</td><td>Pointer to the data of out_scores. </td></tr>
    <tr><td class="paramname">out_scores_size</td><td>Size of out_scores_ptr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HF::OK on completion.</dd></dl>
<p>Similar to SphericalViewAnalysis but uses a flat array of floats instead of an array of nodes. This is to make the SphericalViewAnalysis function more accessible.</p>
<dl class="section user"><dt>Caller's Responsibility</dt><dd>The caller must call <a class="el" href="a00410.html#af77723a4383b278169e80cf0e361ec44">DestroyFloatVector</a> with out_scores to free the memory allocated by this function.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) ERT points to a valid raytracer created by CreateRaytracer. </dd>
<dd>
2) node_ptr contains a valid array of floats with length equal to node_size * 3. </dd>
<dd>
3) out_scores, out_scores_ptr, and out_score_size are not null.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>1) out_scores contains a pointer to score for every node in nodes in order. </dd>
<dd>
2) out_scores_ptr cpoints to a valid array of scores. </dd>
<dd>
3) out_scores_size is updated to the length of the data held by out_scores_ptr.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="a00452.html#_todo000032">Todo:</a></b></dt><dd>Is there any situation where out_scores_size is smaller than node_size?</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00455.html#mesh_setup">Mesh setup</a> (how to create a mesh), <a class="el" href="a00455.html#mesh_teardown">Mesh teardown</a> (how to destroy a mesh) </dd>
<dd>
<a class="el" href="a00457.html#raytracer_setup">Raytracer setup</a> (how to create a BVH), <a class="el" href="a00457.html#raytracer_teardown">Raytracer teardown</a> (how to destroy a BVH)</dd></dl>
<p>Begin by <b>loading an .obj file</b> (<a class="el" href="a00455.html#mesh_setup">Mesh setup</a>).<br  />
 Then, <b>create a BVH</b> (<a class="el" href="a00457.html#raytracer_setup">Raytracer setup</a>) using the <b>mesh</b>.<br  />
</p>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<p>Set up the parameters for the view analysis. </p><div class="fragment"><div class="line">        <span class="comment">// Preparing the parameters for SphericalViewAnalysisAggregateFlat</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Define point to start ray</span></div>
<div class="line">        <span class="comment">// These are Cartesian coordinates.</span></div>
<div class="line">        std::array&lt;float, 3&gt; p1 { 0.0f, 0.0f, 2.0f };</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Define direction to cast ray</span></div>
<div class="line">        <span class="comment">// These are vector components, not Cartesian coordinates.</span></div>
<div class="line">        std::array&lt;float, 3&gt; dir { 0.0f, 0.0f, -1.0f };</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// This is a container of nodes to be analyzed.</span></div>
<div class="line">        <span class="comment">// SphericalViewAnalysisAggregateFlat accepts a (Node *) parameter,</span></div>
<div class="line">        <span class="comment">// so a raw stack-allocated array will suffice.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// This may also be a pointer to a heap-allocated buffer</span></div>
<div class="line">        <span class="comment">// (which is owned by a vector&lt;Node&gt;, accessed via the vector&lt;Node&gt;::data() method).</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// ...or, it can be a pointer to memory allocated by the caller via operator new[node_count]</span></div>
<div class="line">        <span class="comment">// (if this route is taken, be sure to release the memory with operator delete[] after use)</span></div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> node_count = 1;           <span class="comment">// should be the element count in nodes</span></div>
<div class="line">        <span class="keywordtype">int</span> ray_count = 1000;               <span class="comment">// will be mutated by SphericalViewAnalysisAggregateFlat</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> height = 1.7f;          <span class="comment">// height to offset nodes from the ground, in meters</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> upward_fov = 50.0f;     <span class="comment">// default parameter is 50.0f in Python code</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> downward_fov = 70.0f;   <span class="comment">// default parameter is 70.0f in Python code</span></div>
</div><!-- fragment --><p >Now you must prepare a pointer to a std::vector&lt;float&gt;, where the <b>aggregation results</b> will be stored.<br  />
 You must also select the aggregate type. </p><div class="fragment"><div class="line">        <span class="comment">// Declare a pointer to vector&lt;float&gt;, named aggregate_results.</span></div>
<div class="line">        <span class="comment">// This pointer will point to memory on the free store,</span></div>
<div class="line">        <span class="comment">// allocated within SphericalViewAnalysisAggregateFlat.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// aggregate_results_data will point to the underlying buffer within *aggregate_results,</span></div>
<div class="line">        <span class="comment">// which will be assigned inside SphericalViewAnalysisNoAggregateFlat.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Note that we must call operator delete on aggregate_results when we are finished with it.</span></div>
<div class="line">        std::vector&lt;float&gt;* aggregate_results = <span class="keyword">nullptr</span>;</div>
<div class="line">        <span class="keywordtype">float</span>* aggregate_results_data = <span class="keyword">nullptr</span>;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Will be equal to aggregate_results-&gt;size();</span></div>
<div class="line">        <span class="keywordtype">int</span> aggregate_results_size = -1;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Select the aggregate type.</span></div>
<div class="line">        <span class="comment">// This determines how to aggregate the edges within the results of the view analysis.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// AGGREGATE_TYPE::AVERAGE means that the edges will be aggregated</span></div>
<div class="line">        <span class="comment">// by the maximum distance from the origin point to its hit points.</span></div>
<div class="line">        <a class="code hl_enumeration" href="a00443.html#a8a1aa9474094ff70818051c921c0537f">AGGREGATE_TYPE</a> agg_type = <a class="code hl_enumvalue" href="a00443.html#a8a1aa9474094ff70818051c921c0537fa16de38737a9f8366e9b2042b4e9b6290">AGGREGATE_TYPE::AVERAGE</a>;</div>
</div><!-- fragment --><p >Now we are ready to call <a class="el" href="">SphericalViewAnalysisAggregateFlat</a> . </p><div class="fragment"><div class="line">        status = <a class="code hl_function" href="a00459.html#gaa4c5714c1e557ef83a03d447eb30c6d0">SphereicalViewAnalysisAggregateFlat</a>(bvh,</div>
<div class="line">            p1.data(), node_count, ray_count,</div>
<div class="line">            upward_fov, downward_fov, height,</div>
<div class="line">            agg_type,</div>
<div class="line">            &amp;aggregate_results, &amp;aggregate_results_data, &amp;aggregate_results_size);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (status != 1) {</div>
<div class="line">            <span class="comment">// Error!</span></div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error at SphereicalViewAnalysisAggregateFlat, code: &quot;</span> &lt;&lt; status &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="ttc" id="aa00459_html_gaa4c5714c1e557ef83a03d447eb30c6d0"><div class="ttname"><a href="a00459.html#gaa4c5714c1e557ef83a03d447eb30c6d0">SphereicalViewAnalysisAggregateFlat</a></div><div class="ttdeci">C_INTERFACE SphereicalViewAnalysisAggregateFlat(HF::RayTracer::EmbreeRayTracer *ERT, const float *node_ptr, int node_size, int max_rays, float upward_fov, float downward_fov, float height, AGGREGATE_TYPE AT, std::vector&lt; float &gt; **out_scores, float **out_scores_ptr, int *out_scores_size)</div><div class="ttdoc">Conduct view analysis, and aggregate the results.</div><div class="ttdef"><b>Definition:</b> <a href="a00440_source.html#l00050">view_analysis_C.cpp:50</a></div></div>
</div><!-- fragment --><p >We can output the contents of the <b>aggregate results vector</b> to <b>stdout</b>. </p><div class="fragment"><div class="line">        <span class="comment">// Print aggregate results vector (vector&lt;float&gt;)</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span>;</div>
<div class="line">        <span class="keywordtype">int</span> i = 0;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> agg_result : *aggregate_results) {</div>
<div class="line">            std::cout &lt;&lt; agg_result;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (i &lt; aggregate_results-&gt;size() - 1) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            ++i;</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --><p >After using the view analysis results, its resources must be <b>relinquished</b>. </p><div class="fragment"><div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Memory resource cleanup.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// destroy vector&lt;float&gt;</span></div>
<div class="line">        <span class="keywordflow">if</span> (aggregate_results) {</div>
<div class="line">            <span class="keyword">delete</span> aggregate_results;</div>
<div class="line">        }</div>
</div><!-- fragment --><p >From here, please review the example at <a class="el" href="a00457.html#raytracer_teardown">Raytracer teardown</a> for instructions<br  />
 on how to free the remainder of the resources used for the view analysis &ndash;<br  />
 which are the (vector&lt;<a class="el" href="a01351.html">HF::Geometry::MeshInfo</a>&gt; *) and (<a class="el" href="">HF::Raytracer::EmbreeRayTracer</a> *) instances.</p>
<p ><code>&gt;&gt;&gt; LoadOBJ loaded mesh successfully into loaded_obj at address 00000293CC9C84D0, code: 1</code><br  />
<code>&gt;&gt;&gt; CreateRaytracer created EmbreeRayTracer successfully into bvh at address 00000293C3012D20, code: 1</code><br  />
<code>&gt;&gt;&gt; [7.43102]</code><br  />
</p>

<p class="definition">Definition at line <a class="el" href="a00440_source.html#l00050">50</a> of file <a class="el" href="a00440_source.html">view_analysis_C.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00245_source.html#l00024">ConvertRawFloatArrayToPoints()</a>, <a class="el" href="a00176_source.html#l00032">HF::Exceptions::OK</a>, and <a class="el" href="a00023_source.html#l00484">HF::ViewAnalysis::SphericalRayshootWithAnyRTForDistance()</a>.</p>
<div id="dynsection-3" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-3-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-3-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-3-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00459_gaa4c5714c1e557ef83a03d447eb30c6d0_cgraph.svg" width="1272" height="184"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="gaf572b7bec28d55bf2c72719742703dff" name="gaf572b7bec28d55bf2c72719742703dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf572b7bec28d55bf2c72719742703dff">&#9670;&#160;</a></span>SphericalDistribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00407.html#a91fa3b2bb3a7312ec39d74cc1fbc7bbe">C_INTERFACE</a> SphericalDistribute </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>num_rays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; float &gt; **&#160;</td>
          <td class="paramname"><em>out_direction_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname"><em>out_direction_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>upward_fov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>downward_fov</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="a00443.html">Cinterface/view_analysis_C.h</a>&gt;</code></p>

<p>Equally distribute points around a unit sphere. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_rays</td><td>Number of points to distribute.</td></tr>
    <tr><td class="paramname">out_direction_vector</td><td>Output parameter for points generated. Every 3 floats represents a new point.</td></tr>
    <tr><td class="paramname">out_direction_data</td><td>pointer to the data of out_direction_vector </td></tr>
    <tr><td class="paramname">upward_fov</td><td>Maximum degrees upward from the viewer's eye level to consider. </td></tr>
    <tr><td class="paramname">downward_fov</td><td>Maximum degrees downward from the viewer's eye level to consider.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HF::OK on completion.</dd></dl>
<dl class="section user"><dt>Caller's Responsibility</dt><dd>The caller must call <a class="el" href="a00410.html#af77723a4383b278169e80cf0e361ec44">DestroyFloatVector</a> with out_direction_vector to free the memory allocated by this function.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is used internally by all view analysis functions to equally distribute the directions each ray will be casted in.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>out_direction_vector and out_direction_data must not be null, but the pointers they hold can be null.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>1) The pointer pointed to by out_direction_vector contains a vector of directions.</dd>
<dd>
2) num_rays contains the number of points distributed by this function. This may be more or less than the original number depending on the limitations specified by upward and downward fov.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00457.html#raytracer_teardown">Raytracer teardown</a> (how to destroy a BVH) </dd>
<dd>
<a class="el" href="a00455.html#mesh_teardown">Mesh teardown</a> (how to destroy a mesh)</dd></dl>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<p>Begin by <b>initializing</b> input values:<br  />
 </p><div class="fragment"><div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Set arguments</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="keywordtype">int</span> num_rays = 10;                          <span class="comment">// number of points to distribute</span></div>
<div class="line">        std::vector&lt;float&gt;* out_float = <span class="keyword">nullptr</span>;    <span class="comment">// output parameter for points generated</span></div>
<div class="line">        <span class="keywordtype">float</span>* out_float_data;                      <span class="comment">// pointer to buffer within *out_float</span></div>
<div class="line">        <span class="keywordtype">float</span> up_fov = 90.0f;                       <span class="comment">// max degrees upward from viewer&#39;s eye level to consider</span></div>
<div class="line">        <span class="keywordtype">float</span> down_fov = 90.0f;                     <span class="comment">// max degrees downward from viewer&#39;s eye level to consider</span></div>
</div><!-- fragment --><p >We are now ready to call <a class="el" href="a00459.html#gaf572b7bec28d55bf2c72719742703dff">SphericalDistribute</a> . </p><div class="fragment"><div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Call function</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="keyword">auto</span> status = <a class="code hl_function" href="a00459.html#gaf572b7bec28d55bf2c72719742703dff">SphericalDistribute</a>(</div>
<div class="line">            &amp;num_rays,</div>
<div class="line">            &amp;out_float,</div>
<div class="line">            &amp;out_float_data,</div>
<div class="line">            up_fov,</div>
<div class="line">            down_fov</div>
<div class="line">        );</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (status != 1) {</div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error at SphericalDistribute, code: &quot;</span> &lt;&lt; status &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="ttc" id="aa00459_html_gaf572b7bec28d55bf2c72719742703dff"><div class="ttname"><a href="a00459.html#gaf572b7bec28d55bf2c72719742703dff">SphericalDistribute</a></div><div class="ttdeci">C_INTERFACE SphericalDistribute(int *num_rays, vector&lt; float &gt; **out_direction_vector, float **out_direction_data, float upward_fov, float downward_fov)</div><div class="ttdoc">Equally distribute points around a unit sphere.</div><div class="ttdef"><b>Definition:</b> <a href="a00440_source.html#l00126">view_analysis_C.cpp:126</a></div></div>
</div><!-- fragment --><p >Let's output the result, stored in <b>out_float_data</b> (you can also access <b>*out_float</b>). </p><div class="fragment"><div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Print results</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Number of rays: &quot;</span> &lt;&lt; num_rays &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_rays; i++) {</div>
<div class="line">            <span class="keywordtype">int</span> os = i * 3;</div>
<div class="line"> </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;(&quot;</span></div>
<div class="line">                &lt;&lt; out_float_data[os] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span></div>
<div class="line">                &lt;&lt; out_float_data[os + 1] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span></div>
<div class="line">                &lt;&lt; out_float_data[os + 2] &lt;&lt; <span class="stringliteral">&quot;)&quot;</span></div>
<div class="line">                &lt;&lt; std::endl;</div>
<div class="line">        }</div>
</div><!-- fragment --><p >Make sure to destroy the resources addressed by <b>out_float</b> when you are finished with it. </p><div class="fragment"><div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Deallocate Memory</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <a class="code hl_function" href="a00410.html#af77723a4383b278169e80cf0e361ec44">DestroyFloatVector</a>(out_float);</div>
<div class="ttc" id="aa00410_html_af77723a4383b278169e80cf0e361ec44"><div class="ttname"><a href="a00410.html#af77723a4383b278169e80cf0e361ec44">DestroyFloatVector</a></div><div class="ttdeci">C_INTERFACE DestroyFloatVector(std::vector&lt; float &gt; *float_vector)</div><div class="ttdoc">Delete a float vector that's pointed to by float_vector</div><div class="ttdef"><b>Definition:</b> <a href="a00410_source.html#l00027">cinterface_utils.cpp:27</a></div></div>
</div><!-- fragment --><p ><code>&gt;&gt;&gt; Number of rays: 10</code><br  />
<code>&gt;&gt;&gt; (-0, -1, 0)</code><br  />
<code>&gt;&gt;&gt; (-0.276545, -0.8, -0.532469)</code><br  />
<code>&gt;&gt;&gt; (0.751457, -0.6, 0.27443)</code><br  />
<code>&gt;&gt;&gt; (-0.847177, -0.4, 0.349703)</code><br  />
<code>&gt;&gt;&gt; (0.415282, -0.2, -0.887435)</code><br  />
<code>&gt;&gt;&gt; (0.299284, 0, 0.954164)</code><br  />
<code>&gt;&gt;&gt; (-0.847731, 0.2, -0.491275)</code><br  />
<code>&gt;&gt;&gt; (0.895138, 0.4, -0.196795)</code><br  />
<code>&gt;&gt;&gt; (-0.460102, 0.6, 0.654451)</code><br  />
<code>&gt;&gt;&gt; (-0.0771074, 0.8, -0.595025)</code><br  />
</p>

<p class="definition">Definition at line <a class="el" href="a00440_source.html#l00126">126</a> of file <a class="el" href="a00440_source.html">view_analysis_C.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00020_source.html#l00121">HF::ViewAnalysis::FibbonacciDistributePoints()</a>, and <a class="el" href="a00176_source.html#l00032">HF::Exceptions::OK</a>.</p>
<div id="dynsection-4" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-4-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-4-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-4-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00459_gaf572b7bec28d55bf2c72719742703dff_cgraph.svg" width="899" height="171"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ga78f77d24531d0fa55c9b60d7ec1bf32a" name="ga78f77d24531d0fa55c9b60d7ec1bf32a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78f77d24531d0fa55c9b60d7ec1bf32a">&#9670;&#160;</a></span>SphericalRayshootWithAnyRTForDistance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RT , typename N &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; float &gt; HF::ViewAnalysis::SphericalRayshootWithAnyRTForDistance </td>
          <td>(</td>
          <td class="paramtype">RT &amp;&#160;</td>
          <td class="paramname"><em>ray_tracer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>Nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_rays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>upward_limit</em> = <code>50.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>downward_limit</em> = <code>70.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em> = <code>1.7f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00466.html#a1fcaa17d2a8df8896a3b0447973bd07b">AGGREGATE_TYPE</a>&#160;</td>
          <td class="paramname"><em>aggregation</em> = <code><a class="el" href="a00466.html#a1fcaa17d2a8df8896a3b0447973bd07ba6970bdc2201030b9c03fbdcf3973858a">AGGREGATE_TYPE::SUM</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="a00023.html">Cpp/analysismethods/src/view_analysis.h</a>&gt;</code></p>

<p>Conduct view analysis and recieve a summarized set of results for each node.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ray_tracer</td><td>A valid raytracer that already has the geometry loaded. </td></tr>
    <tr><td class="paramname">Nodes</td><td>Points to perform analysis from. </td></tr>
    <tr><td class="paramname">num_rays</td><td>The number of rays to cast from each point in nodes. The actual amount of rays cast may be less or more than this number. Due to how the spherical ray distribution is calculated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upward_limit</td><td>Maximum angle in degrees to cast rays above the viewpoint. </td></tr>
    <tr><td class="paramname">downward_limit</td><td>Maximum angle in degrees to cast rays below the viewpoint. </td></tr>
    <tr><td class="paramname">height</td><td>Height off the ground to cast from. All points in Nodes will be offset this distance from the ground (+Z) before calculations are performed </td></tr>
    <tr><td class="paramname">aggregation</td><td>The type of aggregation to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RT</td><td>A Raytracer with IntersectOutputArguments defined for the type of N. </td></tr>
    <tr><td class="paramname">N</td><td>A point that overloads [] for 0, 1 and 2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Nodes.size() long array of results for each node in Nodes.</dd></dl>
<p>The analysis performed by this function is identical to that described in SphericalViewAnalysis, but results are summarized over the course of the analysis for every observer point instead of recording each individual intersection. The memory usage for this function is drastically lower than that of SphericalViewAnalysis, resulting in lower execution times at the cost of being restricted to a set of predefined aggregation methods.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_array_new_length</td><td>The number of rays is larger than that which can be stored in a std::vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00459.html#ga6ca336e3887ef82d17b0713c2bf862df" title="Evenly distribute a set of points around a sphere centered at the origin.">FibbonacciDistributePoints</a> For details on how the directions are calculated from num_rays. </dd>
<dd>
<a class="el" href="a00459.html#gaecaa04882696ac6d73173227bd28e91b" title="Conduct view analysis with any Raytracer in parallel.">SphericalViewAnalysis</a> to get the result of every ray cast instead of summarizing the results. </dd>
<dd>
<a class="el" href="a00466.html#a1fcaa17d2a8df8896a3b0447973bd07b" title="The type of aggregation to use for ViewAnalysisAggregate">AGGREGATE_TYPE</a> for a list of aggregation methods. </dd>
<dd>
<a class="el" href="a00466.html#a38c197b654c753cb656ab60e88d65120">Aggregate</a> for the implementation of all aggregation methods.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="comment">// Requires #include &quot;view_analysis.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use this so we can fit within 80 characters</span></div>
<div class="line"><span class="keyword">using </span><a class="code hl_function" href="a00459.html#ga78f77d24531d0fa55c9b60d7ec1bf32a">HF::ViewAnalysis::SphericalRayshootWithAnyRTForDistance</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_enumeration" href="a00466.html#a1fcaa17d2a8df8896a3b0447973bd07b">HF::ViewAnalysis::AGGREGATE_TYPE</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_class" href="a01411.html">HF::RayTracer::EmbreeRayTracer</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_class" href="a01351.html">HF::Geometry::MeshInfo</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create Plane</span></div>
<div class="line"><span class="keyword">const</span> std::vector&lt;float&gt; plane_vertices{</div>
<div class="line">    -10.0f, 10.0f, 0.0f,</div>
<div class="line">    -10.0f, -10.0f, 0.0f,</div>
<div class="line">    10.0f, 10.0f, 0.0f,</div>
<div class="line">    10.0f, -10.0f, 0.0f,</div>
<div class="line">};</div>
<div class="line"><span class="keyword">const</span> std::vector&lt;int&gt; plane_indices{ 3, 1, 0, 2, 3, 0 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create RayTracer</span></div>
<div class="line">EmbreeRayTracer ert(std::vector&lt;MeshInfo&gt;{</div>
<div class="line">    <a class="code hl_typedef" href="a00428.html#acea841c68a73d07ad9d772ec2e94a683">MeshInfo</a>(plane_vertices, plane_indices, 0, <span class="stringliteral">&quot; &quot;</span>)}</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define observer points</span></div>
<div class="line">std::vector&lt;std::array&lt;float, 3&gt;&gt; points{</div>
<div class="line">    {0,0,0}, {10,10,0}, {20,20,0}, {30, 30, 0}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Perform View Analysis and sum the distance to all intersections</span></div>
<div class="line"><span class="comment">// for every node</span></div>
<div class="line"><span class="keywordtype">int</span> num_rays = 2000;</div>
<div class="line"><span class="keyword">auto</span> results = <a class="code hl_function" href="a00459.html#ga78f77d24531d0fa55c9b60d7ec1bf32a">SphericalRayshootWithAnyRTForDistance</a>(</div>
<div class="line">    ert, points, num_rays, 90.0f, 90.0f, 1.7f, <a class="code hl_enumvalue" href="a00466.html#a1fcaa17d2a8df8896a3b0447973bd07ba6970bdc2201030b9c03fbdcf3973858a">AGGREGATE_TYPE::SUM</a></div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Print Results</span></div>
<div class="line">std::cerr &lt;&lt; <span class="stringliteral">&quot;(&quot;</span>;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; results.size(); i++) {</div>
<div class="line">    std::cerr &lt;&lt; results[i];</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (i != results.size() - 1) std::cerr &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">}</div>
<div class="line">std::cerr &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div>
<div class="ttc" id="aa00428_html_acea841c68a73d07ad9d772ec2e94a683"><div class="ttname"><a href="a00428.html#acea841c68a73d07ad9d772ec2e94a683">MeshInfo</a></div><div class="ttdeci">HF::Geometry::MeshInfo&lt; float &gt; MeshInfo</div><div class="ttdef"><b>Definition:</b> <a href="a00428_source.html#l00011">raytracer_C.cpp:11</a></div></div>
<div class="ttc" id="aa00459_html_ga78f77d24531d0fa55c9b60d7ec1bf32a"><div class="ttname"><a href="a00459.html#ga78f77d24531d0fa55c9b60d7ec1bf32a">HF::ViewAnalysis::SphericalRayshootWithAnyRTForDistance</a></div><div class="ttdeci">std::vector&lt; float &gt; SphericalRayshootWithAnyRTForDistance(RT &amp;ray_tracer, const std::vector&lt; N &gt; &amp;Nodes, int num_rays, float upward_limit=50.0f, float downward_limit=70.0f, float height=1.7f, const AGGREGATE_TYPE aggregation=AGGREGATE_TYPE::SUM)</div><div class="ttdoc">Conduct view analysis and recieve a summarized set of results for each node.</div><div class="ttdef"><b>Definition:</b> <a href="a00023_source.html#l00484">view_analysis.h:484</a></div></div>
<div class="ttc" id="aa00466_html_a1fcaa17d2a8df8896a3b0447973bd07b"><div class="ttname"><a href="a00466.html#a1fcaa17d2a8df8896a3b0447973bd07b">HF::ViewAnalysis::AGGREGATE_TYPE</a></div><div class="ttdeci">AGGREGATE_TYPE</div><div class="ttdoc">The type of aggregation to use for ViewAnalysisAggregate</div><div class="ttdef"><b>Definition:</b> <a href="a00023_source.html#l00049">view_analysis.h:49</a></div></div>
<div class="ttc" id="aa00466_html_a1fcaa17d2a8df8896a3b0447973bd07ba6970bdc2201030b9c03fbdcf3973858a"><div class="ttname"><a href="a00466.html#a1fcaa17d2a8df8896a3b0447973bd07ba6970bdc2201030b9c03fbdcf3973858a">HF::ViewAnalysis::AGGREGATE_TYPE::SUM</a></div><div class="ttdeci">@ SUM</div><div class="ttdoc">Sum of the distance from the origin to all intersections.</div></div>
<div class="ttc" id="aa01351_html"><div class="ttname"><a href="a01351.html">HF::Geometry::MeshInfo</a></div><div class="ttdoc">A collection of vertices and indices representing geometry.</div><div class="ttdef"><b>Definition:</b> <a href="a00185_source.html#l00124">meshinfo.h:124</a></div></div>
<div class="ttc" id="aa01411_html"><div class="ttname"><a href="a01411.html">HF::RayTracer::EmbreeRayTracer</a></div><div class="ttdoc">A wrapper for Intel's Embree Library.</div><div class="ttdef"><b>Definition:</b> <a href="a00212_source.html#l00083">embree_raytracer.h:83</a></div></div>
</div><!-- fragment --></dd></dl>
<p><code>&gt;&gt;&gt; (2746.72, 932.565, 170.858, 76.8413)</code></p>
<dl class="todo"><dt><b><a class="el" href="a00452.html#_todo000005">Todo:</a></b></dt><dd>Should this have a height check like the one in the <a class="el" href="a00467.html" title="Evaluate visibility between points in a set of locations.">VisibilityGraph</a>?</dd></dl>
<dl class="todo"><dt><b><a class="el" href="a00452.html#_todo000006">Todo:</a></b></dt><dd>Rename this to ViewAnalysisAggregate.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="a00452.html#_todo000007">Todo:</a></b></dt><dd>Potential speed up here by using a Raytracer function that doesn't return the point of intersection. </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00023_source.html#l00484">484</a> of file <a class="el" href="a00023_source.html">view_analysis.h</a>.</p>

<p class="reference">References <a class="el" href="a00023_source.html#l00194">HF::ViewAnalysis::Aggregate()</a>, <a class="el" href="a00020_source.html#l00121">HF::ViewAnalysis::FibbonacciDistributePoints()</a>, and <a class="el" href="a00466.html#a1fcaa17d2a8df8896a3b0447973bd07bace31e2a082d17e038fcc6e3006166653">HF::ViewAnalysis::MIN</a>.</p>

<p class="reference">Referenced by <a class="el" href="a00440_source.html#l00017">SphereicalViewAnalysisAggregate()</a>, and <a class="el" href="a00440_source.html#l00050">SphereicalViewAnalysisAggregateFlat()</a>.</p>
<div id="dynsection-5" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-5-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-5-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-5-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00459_ga78f77d24531d0fa55c9b60d7ec1bf32a_cgraph.svg" width="983" height="171"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div id="dynsection-6" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-6-trigger" src="closed.png" alt="+"/> Here is the caller graph for this function:</div>
<div id="dynsection-6-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-6-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00459_ga78f77d24531d0fa55c9b60d7ec1bf32a_icgraph.svg" width="516" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="gaecaa04882696ac6d73173227bd28e91b" name="gaecaa04882696ac6d73173227bd28e91b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecaa04882696ac6d73173227bd28e91b">&#9670;&#160;</a></span>SphericalViewAnalysis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RES , typename RT , typename N &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; RES &gt; HF::ViewAnalysis::SphericalViewAnalysis </td>
          <td>(</td>
          <td class="paramtype">RT &amp;&#160;</td>
          <td class="paramname"><em>ray_tracer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>Nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_rays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>upward_limit</em> = <code>50.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>downward_limit</em> = <code>70.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em> = <code>1.7f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="a00023.html">Cpp/analysismethods/src/view_analysis.h</a>&gt;</code></p>

<p>Conduct view analysis with any Raytracer in parallel.  </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ray_tracer</td><td>A valid raytracer that already has the geometry loaded. </td></tr>
    <tr><td class="paramname">Nodes</td><td>Points to perform analysis from. </td></tr>
    <tr><td class="paramname">num_rays</td><td>The number of rays to cast from each point in nodes. The actual amount of rays cast may be less or more than this number. Due to how the spherical ray distribution is calculated. </td></tr>
    <tr><td class="paramname">upward_limit</td><td>Maximum angle in degrees to cast rays above the viewpoint. </td></tr>
    <tr><td class="paramname">downward_limit</td><td>Maximum angle in degrees to cast rays below the viewpoint. </td></tr>
    <tr><td class="paramname">height</td><td>Height off the ground to cast from. All points in Nodes will be offset this distance from the ground (+Z) before calculations are performed</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RES</td><td>A class or struct that has a .SetHit() function. This function will be called with the node, direction, distance to intersection, and MeshID intersected for every ray that intersects geometry.</td></tr>
    <tr><td class="paramname">RT</td><td>A Raytracer with IntersectOutputArguments defined for the type of N. </td></tr>
    <tr><td class="paramname">N</td><td>A point that overloads [] for 0, 1 and 2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <em>approximately</em> num_rays * Nodes.size() long vector of RES with one element for every ray cast. Results will be laid out in order with the first node's results first, then the second, etc. Every ray that intersected something, and all elements that didn't result in an intersection will left at their default values.</dd></dl>
<p><a class="el" href="a00466.html" title="Analyze space from the perspective of observers within a 3D environment.">ViewAnalysis</a> is calculated by casting a series of rays equally distributed in a sphere from each point in Nodes. This function will run in parallel using all available cores. Depending on RES, this function's complexity and results can vary.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_array_new_length</td><td>The number of rays is larger than that which can be stored in a std::vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00459.html#ga6ca336e3887ef82d17b0713c2bf862df" title="Evenly distribute a set of points around a sphere centered at the origin.">FibbonacciDistributePoints</a> For details on how the directions are calculated from num_rays. </dd>
<dd>
<a class="el" href="a00459.html#ga78f77d24531d0fa55c9b60d7ec1bf32a" title="Conduct view analysis and recieve a summarized set of results for each node.">SphericalRayshootWithAnyRTForDistance</a> for a more efficent method of getting a summary of the results.</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line"><span class="comment">// Requires #include &quot;view_analysis.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use this so we can fit within 80 characters</span></div>
<div class="line"><span class="keyword">using </span><a class="code hl_function" href="a00459.html#gaecaa04882696ac6d73173227bd28e91b">HF::ViewAnalysis::SphericalViewAnalysis</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_class" href="a01411.html">HF::RayTracer::EmbreeRayTracer</a>;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_class" href="a01351.html">HF::Geometry::MeshInfo</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create Plane</span></div>
<div class="line"><span class="keyword">const</span> std::vector&lt;float&gt; plane_vertices{</div>
<div class="line">    -10.0f, 10.0f, 0.0f,</div>
<div class="line">    -10.0f, -10.0f, 0.0f,</div>
<div class="line">    10.0f, 10.0f, 0.0f,</div>
<div class="line">    10.0f, -10.0f, 0.0f,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> std::vector&lt;int&gt; plane_indices{ 3, 1, 0, 2, 3, 0 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create RayTracer</span></div>
<div class="line">EmbreeRayTracer ert(std::vector&lt;MeshInfo&gt;{</div>
<div class="line">    <a class="code hl_typedef" href="a00428.html#acea841c68a73d07ad9d772ec2e94a683">MeshInfo</a>(plane_vertices, plane_indices, 0, <span class="stringliteral">&quot; &quot;</span>)}</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define a struct that only stores the distance when sethit is called.</span></div>
<div class="line"><span class="keyword">struct </span>SampleResults {</div>
<div class="line">    <span class="keywordtype">float</span> dist = -1.0f;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span> SetHit(</div>
<div class="line">        <span class="keyword">const</span> std::array&lt;float, 3&gt; &amp; node,</div>
<div class="line">        <span class="keyword">const</span> std::array&lt;float, 3&gt; &amp; direction,</div>
<div class="line">        <span class="keywordtype">float</span> distance,</div>
<div class="line">        <span class="keywordtype">int</span> meshID</div>
<div class="line">    ) {</div>
<div class="line">        dist = distance;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define observer points</span></div>
<div class="line">std::vector&lt;std::array&lt;float, 3&gt;&gt; points{</div>
<div class="line">    {0,0,0}, {1,1,0}, {1,2,0}, {1000, 1000, 0}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Perform View Analysis</span></div>
<div class="line"><span class="keywordtype">int</span> num_rays = 50;</div>
<div class="line"><span class="keyword">auto</span> results = SphericalViewAnalysis&lt;SampleResults&gt;(ert, points, num_rays);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Determine how many directions there were since there may have been less than</span></div>
<div class="line"><span class="comment">// what we specified</span></div>
<div class="line"><span class="keywordtype">int</span> num_directions = results.size() / points.size();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Construct a vector from the results of the first node</span></div>
<div class="line">std::vector&lt;SampleResults&gt; first_results(</div>
<div class="line">    results.begin(), results.begin() + num_directions</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Print Results</span></div>
<div class="line">std::cerr &lt;&lt; <span class="stringliteral">&quot;(&quot;</span>;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; first_results.size(); i++) {</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp; result = first_results[i];</div>
<div class="line">    std::cerr &lt;&lt; result.dist;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (i != first_results.size() - 1) std::cerr &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">}</div>
<div class="line">std::cerr &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div>
<div class="ttc" id="aa00459_html_gaecaa04882696ac6d73173227bd28e91b"><div class="ttname"><a href="a00459.html#gaecaa04882696ac6d73173227bd28e91b">HF::ViewAnalysis::SphericalViewAnalysis</a></div><div class="ttdeci">std::vector&lt; RES &gt; SphericalViewAnalysis(RT &amp;ray_tracer, const std::vector&lt; N &gt; &amp;Nodes, int num_rays, float upward_limit=50.0f, float downward_limit=70.0f, float height=1.7f)</div><div class="ttdoc">Conduct view analysis with any Raytracer in parallel.</div><div class="ttdef"><b>Definition:</b> <a href="a00023_source.html#l00335">view_analysis.h:335</a></div></div>
</div><!-- fragment --></dd></dl>
<p><code>&gt;&gt;&gt; (-1, 7.35812, -1, -1, 3.70356, -1, 5.56647, 12.1517, -1, 2.36725, -1, -1, 2.97477, 2.58713, -1,</code> <code>-1, 1.91404, 5.95885, 4.26368, 1.86167, -1, -1, 2.0406, 2.78304, -1, -1, -1, -1, 2.83909, 2.05302,</code> <code>-1, -1, 1.90724, 4.29017, 6.3381, 1.98544, -1, -1, 2.75554, 3.15929, -1, -1, 2.6345, -1, -1,</code> <code>6.80486, -1, 5.12012, -1)</code></p>
<dl class="todo"><dt><b><a class="el" href="a00452.html#_todo000004">Todo:</a></b></dt><dd>Should this have a height check like the one in the <a class="el" href="a00467.html" title="Evaluate visibility between points in a set of locations.">VisibilityGraph</a>?</dd></dl>

<p class="definition">Definition at line <a class="el" href="a00023_source.html#l00335">335</a> of file <a class="el" href="a00023_source.html">view_analysis.h</a>.</p>

<p class="reference">References <a class="el" href="a00020_source.html#l00121">HF::ViewAnalysis::FibbonacciDistributePoints()</a>.</p>
<div id="dynsection-7" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-7-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-7-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-7-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00459_gaecaa04882696ac6d73173227bd28e91b_cgraph.svg" width="955" height="171"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="ga94d3ddc3981020e2852fc77e51266185" name="ga94d3ddc3981020e2852fc77e51266185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94d3ddc3981020e2852fc77e51266185">&#9670;&#160;</a></span>SphericalViewAnalysisNoAggregate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00407.html#a91fa3b2bb3a7312ec39d74cc1fbc7bbe">C_INTERFACE</a> SphericalViewAnalysisNoAggregate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01411.html">HF::RayTracer::EmbreeRayTracer</a> *&#160;</td>
          <td class="paramname"><em>ERT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a02071.html">HF::SpatialStructures::Node</a> *&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>max_rays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>upward_fov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>downward_fov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="a02087.html">RayResult</a> &gt; **&#160;</td>
          <td class="paramname"><em>out_results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02087.html">RayResult</a> **&#160;</td>
          <td class="paramname"><em>out_results_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="a00443.html">Cinterface/view_analysis_C.h</a>&gt;</code></p>

<p>Perform view analysis, then get the distance and meshid for each individual ray casted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ERT</td><td>Raytracer containing the geometry to use for ray intersections. </td></tr>
    <tr><td class="paramname">node_ptr</td><td>Observer points for the view analysis. </td></tr>
    <tr><td class="paramname">node_size</td><td>Number of nodes in the array pointed to by node_ptr.</td></tr>
    <tr><td class="paramname">max_rays</td><td>Number of rays to cast for each node in node_ptr. This will be updated with the actual number of rays casted upon completion.</td></tr>
    <tr><td class="paramname">upward_fov</td><td>Maximum degrees upward from the viewer's eye level to consider. </td></tr>
    <tr><td class="paramname">downward_fov</td><td>Maximum degrees downward from the viewer's eye level to consider. </td></tr>
    <tr><td class="paramname">height</td><td>Height to offset nodes from the ground (+Z direction). </td></tr>
    <tr><td class="paramname">out_results</td><td>Pointer to the vector containing the results of every ray casted. </td></tr>
    <tr><td class="paramname">out_results_ptr</td><td>Pointer to the data of out_results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HF::OK on completion.</dd></dl>
<p>Rays that do not intersect with any geometry will have a meshid of -1.</p>
<dl class="section user"><dt>Caller's Responsibility</dt><dd>The caller must call <a class="el" href="a00457.html#ga5a68e1d668554f73ee06de8aeeaaffad">DestroyRayResultVector</a> with out_results to free the memory allocated by this function.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) ERT points to a valid raytracer created by <a class="el" href="a00457.html#ga3ac702d080e493d1fa8be6cf4243e38b">CreateRaytracer</a>. </dd>
<dd>
2) node_ptr contains a valid array of nodes with length equal to node_size. </dd>
<dd>
3) node_ptr, max_rays, and ERT are not null.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>1) out_results contains a pointer to score for every node in nodes in order. </dd>
<dd>
2) out_results_ptr points to a valid array of scores. </dd>
<dd>
3) max_rays is updated to the number of rays casted in the view analysis.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00455.html#mesh_setup">Mesh setup</a> (how to create a mesh), <a class="el" href="a00455.html#mesh_teardown">Mesh teardown</a> (how to destroy a mesh) </dd>
<dd>
<a class="el" href="a00457.html#raytracer_setup">Raytracer setup</a> (how to create a BVH), <a class="el" href="a00457.html#raytracer_teardown">Raytracer teardown</a> (how to destroy a BVH)</dd>
<dd>
<a class="el" href="a00459.html#gaf572b7bec28d55bf2c72719742703dff" title="Equally distribute points around a unit sphere.">SphericalDistribute</a> to get the direction of every ray casted by this function. Can be useful to determine the point of intersection for every ray casted.</dd></dl>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<p>Begin by <b>loading an .obj file</b> (<a class="el" href="a00455.html#mesh_setup">Mesh setup</a>).<br  />
 Then, <b>create a BVH</b> (<a class="el" href="a00457.html#raytracer_setup">Raytracer setup</a>) using the <b>mesh</b>.<br  />
</p>
<p >Set up the parameters for the view analysis. </p><div class="fragment"><div class="line">        <span class="comment">// Preparing the parameters for SphericalViewAnalysisNoAggregate</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Define point to start ray</span></div>
<div class="line">        <span class="comment">// These are Cartesian coordinates.</span></div>
<div class="line">        std::array&lt;Node, 1&gt; p1{ Node(0.0f, 0.0f, 2.0f) };</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Define direction to cast ray</span></div>
<div class="line">        <span class="comment">// These are vector components, not Cartesian coordinates.</span></div>
<div class="line">        std::array&lt;float, 3&gt; dir { 0.0f, 0.0f, -1.0f };</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// This is a container of nodes to be analyzed.</span></div>
<div class="line">        <span class="comment">// SphericalViewAnalysisNoAggregate accepts a (Node *) parameter,</span></div>
<div class="line">        <span class="comment">// so a raw stack-allocated array will suffice.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// This may also be a pointer to a heap-allocated buffer</span></div>
<div class="line">        <span class="comment">// (which is owned by a vector&lt;Node&gt;, accessed via the vector&lt;Node&gt;::data() method).</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// ...or, it can be a pointer to memory allocated by the caller via operator new[node_count]</span></div>
<div class="line">        <span class="comment">// (if this route is taken, be sure to release the memory with operator delete[] after use)</span></div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> node_count = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(p1.size()); <span class="comment">// should be the element count in nodes</span></div>
<div class="line">        <span class="keywordtype">int</span> ray_count = 1000;               <span class="comment">// will be mutated by SphericalViewAnalysisNoAggregate</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> height = 1.7f;          <span class="comment">// height to offset nodes from the ground, in meters</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> upward_fov = 50.0f;     <span class="comment">// default parameter is 50.0f in Python code</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> downward_fov = 70.0f;   <span class="comment">// default parameter is 70.0f in Python code</span></div>
</div><!-- fragment --><p >Now you must prepare a pointer to a std::vector&lt;<a class="el" href="a02087.html">RayResult</a>&gt;.<br  />
 View analysis results will be stored at the memory addressed by this pointer. </p><div class="fragment"><div class="line">        <span class="comment">// Declare a pointer to vector&lt;RayResult&gt;, named results.</span></div>
<div class="line">        <span class="comment">// This pointer will point to memory on the free store,</span></div>
<div class="line">        <span class="comment">// allocated within SphericalViewAnalysisNoAggregate.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// results_data will point to the underlying buffer within *results,</span></div>
<div class="line">        <span class="comment">// which will be assigned inside SphericalViewAnalysisNoAggregate.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Note that we must call operator delete on results when we are finished with it.</span></div>
<div class="line">        std::vector&lt;RayResult&gt;* results = <span class="keyword">nullptr</span>;</div>
<div class="line">        <a class="code hl_struct" href="a02087.html">RayResult</a>* results_data = <span class="keyword">nullptr</span>;</div>
<div class="ttc" id="aa02087_html"><div class="ttname"><a href="a02087.html">RayResult</a></div><div class="ttdoc">The result of casting a ray at an object. Contains distance to the hitpoint and the ID of the mesh.</div><div class="ttdef"><b>Definition:</b> <a href="a00431_source.html#l00092">raytracer_C.h:92</a></div></div>
</div><!-- fragment --><p >Now we are ready to call <a class="el" href="a00459.html#ga94d3ddc3981020e2852fc77e51266185">SphericalViewAnalysisNoAggregate</a> . </p><div class="fragment"><div class="line">        <span class="comment">// Conducting a view analysis on the node at position p1.</span></div>
<div class="line">        status = <a class="code hl_function" href="a00459.html#ga94d3ddc3981020e2852fc77e51266185">SphericalViewAnalysisNoAggregate</a>(bvh,</div>
<div class="line">            p1.data(), node_count, &amp;ray_count,</div>
<div class="line">            upward_fov, downward_fov, height,</div>
<div class="line">            &amp;results, &amp;results_data);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (status != 1) {</div>
<div class="line">            <span class="comment">// Error!</span></div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error at SphericalViewAnalysisNoAggregate, code: &quot;</span> &lt;&lt; status &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="ttc" id="aa00459_html_ga94d3ddc3981020e2852fc77e51266185"><div class="ttname"><a href="a00459.html#ga94d3ddc3981020e2852fc77e51266185">SphericalViewAnalysisNoAggregate</a></div><div class="ttdeci">C_INTERFACE SphericalViewAnalysisNoAggregate(HF::RayTracer::EmbreeRayTracer *ERT, const HF::SpatialStructures::Node *node_ptr, int node_size, int *max_rays, float upward_fov, float downward_fov, float height, std::vector&lt; RayResult &gt; **out_results, RayResult **out_results_ptr)</div><div class="ttdoc">Perform view analysis, then get the distance and meshid for each individual ray casted.</div><div class="ttdef"><b>Definition:</b> <a href="a00440_source.html#l00073">view_analysis_C.cpp:73</a></div></div>
</div><!-- fragment --><p >We can output the contents of the <b>aggregate results vector</b> to <b>stdout</b>. </p><div class="fragment"><div class="line">        <span class="comment">// Print results vector (vector&lt;RayResult&gt;)</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> start_range = 15;</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> end_range = 20;</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span>;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = start_range; i &lt; end_range; i++) {</div>
<div class="line">            <span class="keyword">auto</span> result = (*results)[i];</div>
<div class="line"> </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; result.distance &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; result.meshid &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (i &lt; end_range - 1) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --><p >After using the view analysis results, its resources must be <b>relinquished</b>. </p><div class="fragment"><div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Memory resource cleanup.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// destroy vector&lt;RayResult&gt;</span></div>
<div class="line">        <span class="keywordflow">if</span> (results) {</div>
<div class="line">            <span class="keyword">delete</span> results;</div>
<div class="line">        }</div>
</div><!-- fragment --><p >From here, please review the example at <a class="el" href="a00457.html#raytracer_teardown">Raytracer teardown</a> for instructions<br  />
 on how to free the remainder of the resources used for the view analysis &ndash;<br  />
 which are the (vector&lt;<a class="el" href="a01351.html">HF::Geometry::MeshInfo</a>&gt; *) and (<a class="el" href="">HF::Raytracer::EmbreeRayTracer</a> *) instances.</p>
<p ><code>&gt;&gt;&gt; LoadOBJ loaded mesh successfully into loaded_obj at address 00000293CC9C84D0, code: 1</code><br  />
<code>&gt;&gt;&gt; CreateRaytracer created EmbreeRayTracer successfully into bvh at address 00000293C3012500, code: 1</code><br  />
<code>&gt;&gt;&gt; [(-1, -1), (-1, -1), (15.8334, 0), (-1, -1), (-1, -1)]</code><br  />
</p>

<p class="definition">Definition at line <a class="el" href="a00440_source.html#l00073">73</a> of file <a class="el" href="a00440_source.html">view_analysis_C.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00176_source.html#l00032">HF::Exceptions::OK</a>.</p>

</div>
</div>
<a id="ga348af4492f3e4e7ffab6da3e86de3924" name="ga348af4492f3e4e7ffab6da3e86de3924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga348af4492f3e4e7ffab6da3e86de3924">&#9670;&#160;</a></span>SphericalViewAnalysisNoAggregateFlat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00407.html#a91fa3b2bb3a7312ec39d74cc1fbc7bbe">C_INTERFACE</a> SphericalViewAnalysisNoAggregateFlat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01411.html">HF::RayTracer::EmbreeRayTracer</a> *&#160;</td>
          <td class="paramname"><em>ERT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>node_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>max_rays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>upward_fov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>downward_fov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="a02087.html">RayResult</a> &gt; **&#160;</td>
          <td class="paramname"><em>out_results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a02087.html">RayResult</a> **&#160;</td>
          <td class="paramname"><em>out_results_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>#include &lt;<a class="el" href="a00443.html">Cinterface/view_analysis_C.h</a>&gt;</code></p>

<p>Perform view analysis, and get the distance and meshid for each individual ray casted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ERT</td><td>Raytracer containing the geometry to use for ray intersections.</td></tr>
    <tr><td class="paramname">node_ptr</td><td>observer points for the view analysis. Every 3 elements represents the x,y,z coordinates of a new point.</td></tr>
    <tr><td class="paramname">node_size</td><td>number of nodes in the array pointed to by node_ptr. Should be equal to the length of the array contained by node_ptr * 3.</td></tr>
    <tr><td class="paramname">max_rays</td><td>number of rays to cast for each node in node_ptr. This will be updated with the actual number of rays casted upon completion.</td></tr>
    <tr><td class="paramname">upward_fov</td><td>Maximum degrees upward from the viewer's eye level to consider. </td></tr>
    <tr><td class="paramname">downward_fov</td><td>Maximum degrees downward from the viewer's eye level to consider. </td></tr>
    <tr><td class="paramname">height</td><td>Height to offset nodes from the ground (+Z direction). </td></tr>
    <tr><td class="paramname">out_results</td><td>Pointer to the vector containing the results of every ray casted. </td></tr>
    <tr><td class="paramname">out_results_ptr</td><td>Pointer to the data of out_results.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>HF::OK on completion.</dd></dl>
<p>Rays that do not intersect with any geometry will have a meshid of -1.</p>
<dl class="section user"><dt>Caller's Responsibility</dt><dd>The caller must call <a class="el" href="a00457.html#ga5a68e1d668554f73ee06de8aeeaaffad">DestroyRayResultVector</a> with out_results to free the memory allocated by this function.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>1) ERT points to a valid raytracer created by <a class="el" href="a00457.html#ga3ac702d080e493d1fa8be6cf4243e38b">CreateRaytracer</a>. </dd>
<dd>
2) node_ptr contains a valid array of floats with length equal to node_size *3 . </dd>
<dd>
3) node_ptr, max_rays, and ERT are not null.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>1) out_scores contains a pointer to score for every node in nodes in order. </dd>
<dd>
2) out_scores_ptr cpoints to a valid array of scores. </dd>
<dd>
3) max_rays is updated to the number of rays casted in the view analysis.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00455.html#mesh_setup">Mesh setup</a> (how to create a mesh), <a class="el" href="a00455.html#mesh_teardown">Mesh teardown</a> (how to destroy a mesh) </dd>
<dd>
<a class="el" href="a00457.html#raytracer_setup">Raytracer setup</a> (how to create a BVH), <a class="el" href="a00457.html#raytracer_teardown">Raytracer teardown</a> (how to destroy a BVH)</dd>
<dd>
<a class="el" href="a00459.html#gaf572b7bec28d55bf2c72719742703dff" title="Equally distribute points around a unit sphere.">SphericalDistribute</a> to get the direction of every ray casted by this function. Can be useful to determine the point of intersection for every ray casted.</dd></dl>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<p>Begin by <b>loading an .obj file</b> (<a class="el" href="a00455.html#mesh_setup">Mesh setup</a>).<br  />
 Then, <b>create a BVH</b> (<a class="el" href="a00457.html#raytracer_setup">Raytracer setup</a>) using the <b>mesh</b>.<br  />
</p>
<p >Set up the parameters for the view analysis. </p><div class="fragment"><div class="line">        <span class="comment">// Preparing the parameters for SphericalViewAnalysisNoAggregateFlat</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Define point to start ray</span></div>
<div class="line">        <span class="comment">// These are Cartesian coordinates.</span></div>
<div class="line">        std::array&lt;float, 3&gt; p1 { 0.0f, 0.0f, 2.0f };</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Define direction to cast ray</span></div>
<div class="line">        <span class="comment">// These are vector components, not Cartesian coordinates.</span></div>
<div class="line">        std::array&lt;float, 3&gt; dir { 0.0f, 0.0f, -1.0f };</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// This is a container of nodes to be analyzed.</span></div>
<div class="line">        <span class="comment">// SphericalViewAnalysisNoAggregateFlat accepts a (Node *) parameter,</span></div>
<div class="line">        <span class="comment">// so a raw stack-allocated array will suffice.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// This may also be a pointer to a heap-allocated buffer</span></div>
<div class="line">        <span class="comment">// (which is owned by a vector&lt;Node&gt;, accessed via the vector&lt;Node&gt;::data() method).</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// ...or, it can be a pointer to memory allocated by the caller via operator new[node_count]</span></div>
<div class="line">        <span class="comment">// (if this route is taken, be sure to release the memory with operator delete[] after use)</span></div>
<div class="line"> </div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> node_count = 1;           <span class="comment">// should be the element count in nodes</span></div>
<div class="line">        <span class="keywordtype">int</span> ray_count = 1000;               <span class="comment">// will be mutated by SphericalViewAnalysisNoAggregateFlat</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> height = 1.7f;          <span class="comment">// height to offset nodes from the ground, in meters</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> upward_fov = 50.0f;     <span class="comment">// default parameter is 50.0f in Python code</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> downward_fov = 70.0f;   <span class="comment">// default parameter is 70.0f in Python code</span></div>
</div><!-- fragment --><p >Now you must prepare a pointer to a std::vector&lt;<a class="el" href="a02087.html">RayResult</a>&gt;.<br  />
 View analysis results will be stored at the memory addressed by this pointer. </p><div class="fragment"><div class="line">        <span class="comment">// Declare a pointer to vector&lt;RayResult&gt;, named results.</span></div>
<div class="line">        <span class="comment">// This pointer will point to memory on the free store,</span></div>
<div class="line">        <span class="comment">// allocated within SphericalViewAnalysisNoAggregateFlat.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// results_data will point to the underlying buffer within *results,</span></div>
<div class="line">        <span class="comment">// which will be assigned inside SphericalViewAnalysisNoAggregateFlat.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Note that we must call operator delete on results when we are finished with it.</span></div>
<div class="line">        std::vector&lt;RayResult&gt;* results = <span class="keyword">nullptr</span>;</div>
<div class="line">        <a class="code hl_struct" href="a02087.html">RayResult</a>* results_data = <span class="keyword">nullptr</span>;</div>
</div><!-- fragment --><p >We are now ready to call <a class="el" href="a00459.html#ga348af4492f3e4e7ffab6da3e86de3924">SphericalViewAnalysisNoAggregateFlat</a>. </p><div class="fragment"><div class="line">        <span class="comment">// Conducting a view analysis on the node at position p1.</span></div>
<div class="line">        status = <a class="code hl_function" href="a00459.html#ga348af4492f3e4e7ffab6da3e86de3924">SphericalViewAnalysisNoAggregateFlat</a>(bvh,</div>
<div class="line">            p1.data(), node_count, &amp;ray_count,</div>
<div class="line">            upward_fov, downward_fov, height,</div>
<div class="line">            &amp;results, &amp;results_data);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (status != 1) {</div>
<div class="line">            <span class="comment">// Error!</span></div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;Error at SphericalViewAnalysisNoAggregateFlat, code: &quot;</span> &lt;&lt; status &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="ttc" id="aa00459_html_ga348af4492f3e4e7ffab6da3e86de3924"><div class="ttname"><a href="a00459.html#ga348af4492f3e4e7ffab6da3e86de3924">SphericalViewAnalysisNoAggregateFlat</a></div><div class="ttdeci">C_INTERFACE SphericalViewAnalysisNoAggregateFlat(HF::RayTracer::EmbreeRayTracer *ERT, const float *node_ptr, int node_size, int *max_rays, float upward_fov, float downward_fov, float height, std::vector&lt; RayResult &gt; **out_results, RayResult **out_results_ptr)</div><div class="ttdoc">Perform view analysis, and get the distance and meshid for each individual ray casted.</div><div class="ttdef"><b>Definition:</b> <a href="a00440_source.html#l00106">view_analysis_C.cpp:106</a></div></div>
</div><!-- fragment --><p >We can output the contents of the <b>results vector</b> to <b>stdout</b>. </p><div class="fragment"><div class="line">        <span class="comment">// Print results vector (vector&lt;RayResult&gt;)</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> start_range = 15;</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> end_range = 20;</div>
<div class="line"> </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span>;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = start_range; i &lt; end_range; i++) {</div>
<div class="line">            <span class="keyword">auto</span> result = (*results)[i];</div>
<div class="line"> </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; result.distance &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; result.meshid &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (i &lt; end_range - 1) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;]&quot;</span> &lt;&lt; std::endl;</div>
</div><!-- fragment --><p >After using the view analysis results, its resources must be <b>relinquished</b>. </p><div class="fragment"><div class="line">        <span class="comment">//</span></div>
<div class="line">        <span class="comment">// Memory resource cleanup.</span></div>
<div class="line">        <span class="comment">//</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// destroy vector&lt;RayResult&gt;</span></div>
<div class="line">        <span class="keywordflow">if</span> (results) {</div>
<div class="line">            <span class="keyword">delete</span> results;</div>
<div class="line">        }</div>
</div><!-- fragment --><p >From here, please review the example at <a class="el" href="a00457.html#raytracer_teardown">Raytracer teardown</a> for instructions<br  />
 on how to free the remainder of the resources used for the view analysis &ndash;<br  />
 which are the (vector&lt;<a class="el" href="a01351.html">HF::Geometry::MeshInfo</a>&gt; *) and (<a class="el" href="">HF::Raytracer::EmbreeRayTracer</a> *) instances.</p>
<p ><code>&gt;&gt;&gt; LoadOBJ loaded mesh successfully into loaded_obj at address 00000293CC9C8290, code: 1</code><br  />
<code>&gt;&gt;&gt; CreateRaytracer created EmbreeRayTracer successfully into bvh at address 00000293C3012D20, code: 1</code><br  />
<code>&gt;&gt;&gt; [(-1, -1), (-1, -1), (15.8334, 0), (-1, -1), (-1, -1)]</code><br  />
</p>

<p class="definition">Definition at line <a class="el" href="a00440_source.html#l00106">106</a> of file <a class="el" href="a00440_source.html">view_analysis_C.cpp</a>.</p>

<p class="reference">References <a class="el" href="a00245_source.html#l00024">ConvertRawFloatArrayToPoints()</a>, and <a class="el" href="a00176_source.html#l00032">HF::Exceptions::OK</a>.</p>
<div id="dynsection-8" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-8-trigger" src="closed.png" alt="+"/> Here is the call graph for this function:</div>
<div id="dynsection-8-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-8-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="a00459_ga348af4492f3e4e7ffab6da3e86de3924_cgraph.svg" width="516" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
