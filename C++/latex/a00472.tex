\hypertarget{a00472}{}\doxysection{HF\+::Pathfinding Namespace Reference}
\label{a00472}\index{HF::Pathfinding@{HF::Pathfinding}}


Algorithms to find the shortest path between nodes in a \mbox{\hyperlink{a01551}{HF\+::\+Spatial\+Structures\+::\+Graph}}.  


\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{a01383}{Boost\+Graph}}
\begin{DoxyCompactList}\small\item\em A graph usable with the Boost\+Graph\+Library. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{a01391}{Boost\+Graph\+Deleter}}
\begin{DoxyCompactList}\small\item\em Deleter for the \mbox{\hyperlink{a01383}{Boost\+Graph}}. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{a01395}{Distance\+And\+Predecessor}}
\begin{DoxyCompactList}\small\item\em Holds and maintains a distance and predecessor matrix. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{a01387}{Dist\+Pred}}
\begin{DoxyCompactList}\small\item\em A single row of a distance and predecessor matrix. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{a00472_a01375}{Edge\+\_\+\+Cost}}
\begin{DoxyCompactList}\small\item\em Data stored for every edge in the \mbox{\hyperlink{a01383}{Boost\+Graph}}.   \mbox{\hyperlink{a00472_a01375}{More...}}\end{DoxyCompactList}\item 
struct \mbox{\hyperlink{a00472_a01379}{vertex\+\_\+data}}
\begin{DoxyCompactList}\small\item\em Data stored for every vertex in the \mbox{\hyperlink{a01383}{Boost\+Graph}}.  \mbox{\hyperlink{a00472_a01379}{More...}}\end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef boost\+::compressed\+\_\+sparse\+\_\+row\+\_\+graph$<$ boost\+::directedS, \mbox{\hyperlink{a00472_a01379}{vertex\+\_\+data}}, \mbox{\hyperlink{a00472_a01375}{Edge\+\_\+\+Cost}} $>$ \mbox{\hyperlink{a00472_a9314d552e0a8092644fa080c9945bd25}{graph\+\_\+t}}
\begin{DoxyCompactList}\small\item\em Type of graph held by the \mbox{\hyperlink{a01383}{Boost\+Graph}}. \end{DoxyCompactList}\item 
typedef boost\+::graph\+\_\+traits$<$ \mbox{\hyperlink{a00472_a9314d552e0a8092644fa080c9945bd25}{graph\+\_\+t}} $>$\+::vertex\+\_\+descriptor \mbox{\hyperlink{a00472_a4dc50f188646ed884b58b3e26c7932a5}{vertex\+\_\+descriptor}}
\begin{DoxyCompactList}\small\item\em Quick alias to shorten the typename of vertex descriptors for our graph\+\_\+t type. /summary\texorpdfstring{$>$}{>} \end{DoxyCompactList}\item 
typedef std\+::pair$<$ int, int $>$ \mbox{\hyperlink{a00472_acc378c1e475802d96758aaef12d33dbc}{pair}}
\begin{DoxyCompactList}\small\item\em Shorten std\+::pair to simplify graph construction.  \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{a02083}{Path}} \mbox{\hyperlink{a00472_a977e4c93a977ab4e9e784d1e6fec79f4}{Construct\+Shortest\+Path\+From\+Pred}} (int start, int end, const std\+::vector$<$ size\+\_\+t $>$ \&pred, const std\+::vector$<$ float $>$ \&distances)
\begin{DoxyCompactList}\small\item\em Construct the shortest path from start to end using the given predecessor and distance vectors. \end{DoxyCompactList}\item 
\mbox{\hyperlink{a02083}{Path}} \mbox{\hyperlink{a00472_a322ac32effd41c99359b82df0890e34a}{Construct\+Shortest\+Path\+From\+Pred}} (int start, int end, const \mbox{\hyperlink{a01387}{Dist\+Pred}} \&dist\+\_\+pred)
\begin{DoxyCompactList}\small\item\em Overload to call this with a dist\+Pred instead of the raw arrays. \end{DoxyCompactList}\item 
\mbox{\hyperlink{a01387}{Dist\+Pred}} \mbox{\hyperlink{a00472_a9f6490539108da057db2486295458886}{Build\+Distance\+And\+Predecessor}} (const \mbox{\hyperlink{a00472_a9314d552e0a8092644fa080c9945bd25}{graph\+\_\+t}} \&g, int id)
\begin{DoxyCompactList}\small\item\em Build a row of the distance and predecessor matrices for the node at id. \end{DoxyCompactList}\item 
\mbox{\hyperlink{a02083}{Path}} \mbox{\hyperlink{a00472_a47d06b1c4bd84f4d0a7519ea0e96ff02}{Find\+Path}} (\mbox{\hyperlink{a01383}{Boost\+Graph}} $\ast$bg, int start\+\_\+id, int end\+\_\+id)
\begin{DoxyCompactList}\small\item\em Find a path between points A and B using Dijkstra\textquotesingle{}s Shortest Path algorithm.  \end{DoxyCompactList}\item 
vector$<$ \mbox{\hyperlink{a02083}{Path}} $>$ \mbox{\hyperlink{a00472_a15badb9d0a17849de7b21105605c9c91}{Find\+Paths}} (\mbox{\hyperlink{a01383}{Boost\+Graph}} $\ast$bg, const std\+::vector$<$ int $>$ \&start\+\_\+points, const std\+::vector$<$ int $>$ \&end\+\_\+points)
\begin{DoxyCompactList}\small\item\em Find a path from every id in start\+\_\+ids to the matching end node in end\+\_\+ids. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{a00472_a417084c97d0672af2da7739157a9d8c0}{Insert\+Paths\+Into\+Array}} (const \mbox{\hyperlink{a01383}{Boost\+Graph}} $\ast$bg, const std\+::vector$<$ int $>$ \&start\+\_\+points, const std\+::vector$<$ int $>$ \&end\+\_\+points, \mbox{\hyperlink{a02083}{HF\+::\+Spatial\+Structures\+::\+Path}} $\ast$$\ast$out\+\_\+paths, \mbox{\hyperlink{a02079}{HF\+::\+Spatial\+Structures\+::\+Path\+Member}} $\ast$$\ast$out\+\_\+path\+\_\+members, int $\ast$out\+\_\+sizes)
\begin{DoxyCompactList}\small\item\em A special version of Find\+Paths optimized for the C\+\_\+\+Interface. \end{DoxyCompactList}\item 
\mbox{\hyperlink{a01395}{Distance\+And\+Predecessor}} \mbox{\hyperlink{a00472_ab58662be8e56c333d74d60a823e810e3}{Generate\+Distance\+And\+Pred}} (const \mbox{\hyperlink{a01383}{Boost\+Graph}} \&bg)
\begin{DoxyCompactList}\small\item\em Generate the distance and predecessor matricies for a specific boost graph. \end{DoxyCompactList}\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{a01383}{Boost\+Graph}}, \mbox{\hyperlink{a01391}{Boost\+Graph\+Deleter}} $>$ \mbox{\hyperlink{a00472_ae2106e09eb44d681fbc6c0f66a3d3ac4}{Create\+Boost\+Graph}} (const \mbox{\hyperlink{a01551}{HF\+::\+Spatial\+Structures\+::\+Graph}} \&g, const std\+::string \&cost\+\_\+type=\char`\"{}\char`\"{})
\begin{DoxyCompactList}\small\item\em Create a new boost graph from a \mbox{\hyperlink{a00465}{HF\+::\+Spatial\+Structures}}\+:Graph. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{a00472_a69bd3efcc13788e7c4be43b67d6002e5}{Insert\+All\+To\+All\+Paths\+Into\+Array}} (\mbox{\hyperlink{a01383}{Boost\+Graph}} $\ast$bg, \mbox{\hyperlink{a02083}{HF\+::\+Spatial\+Structures\+::\+Path}} $\ast$$\ast$out\+\_\+paths, \mbox{\hyperlink{a02079}{HF\+::\+Spatial\+Structures\+::\+Path\+Member}} $\ast$$\ast$out\+\_\+path\+\_\+members, int $\ast$out\+\_\+sizes)
\begin{DoxyCompactList}\small\item\em A special version of Find\+Paths optimized for the C\+\_\+\+Interface, such that all paths possible from each node to every other node are generated. \end{DoxyCompactList}\item 
std\+::vector$<$ int $>$ \mbox{\hyperlink{a00472_a3d6e0ea77f750fa05bbf4339584cc15a}{Construct\+Shortest\+Path\+Nodes\+From\+Pred}} (int start, int end, const std\+::vector$<$ size\+\_\+t $>$ \&pred)
\begin{DoxyCompactList}\small\item\em Construct the shortest path of node ids given predecessor and distance vectors. \end{DoxyCompactList}\item 
std\+::vector$<$ std\+::vector$<$ int $>$ $>$ \mbox{\hyperlink{a00472_a6d24adcb1c0891a98e7d9a8d36f8cc01}{Find\+APSP}} (\mbox{\hyperlink{a01383}{Boost\+Graph}} \&bg)
\item 
std\+::vector$<$ \mbox{\hyperlink{a02083}{HF\+::\+Spatial\+Structures\+::\+Path}} $>$ \mbox{\hyperlink{a00472_abb65ba6c3ed7a1999d9f40ae14ba3269}{Find\+All\+Paths}} (\mbox{\hyperlink{a01383}{Boost\+Graph}} $\ast$bg)
\item 
\mbox{\hyperlink{a01395}{Distance\+And\+Predecessor}} \mbox{\hyperlink{a00472_a496379e77c1c41453ef021358f8372fb}{Generate\+Distance\+And\+Pred\+Fast}} (const \mbox{\hyperlink{a01383}{Boost\+Graph}} \&bg)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Algorithms to find the shortest path between nodes in a \mbox{\hyperlink{a01551}{HF\+::\+Spatial\+Structures\+::\+Graph}}. 

This namespace utilizes pathfinding algorithms from Boost internally.\+To make use of the algorithms in this namespace, first you must create a \mbox{\hyperlink{a01383}{Boost\+Graph}} from the \mbox{\hyperlink{a01551}{HF\+::\+Spatial\+Structures\+::\+Graph}} you want to find paths in. ~\newline


\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{a02083}{HF\+::\+Spatial\+Structures\+::\+Path}} for a description of the path datatype. 

\mbox{\hyperlink{a01383}{Boost\+Graph}} for details on generating a \mbox{\hyperlink{a01383}{Boost\+Graph}} from a \mbox{\hyperlink{a01551}{HF\+::\+Spatial\+Structures\+::\+Graph}}. 
\end{DoxySeeAlso}


\doxysubsection{Class Documentation}
\index{HF::Pathfinding::Edge\_Cost@{HF::Pathfinding::Edge\_Cost}}\label{a01375}
\Hypertarget{a00472_a01375}
\doxysubsubsection{struct HF\+::Pathfinding\+::Edge\+\_\+\+Cost}
Data stored for every edge in the \mbox{\hyperlink{a01383}{Boost\+Graph}}.  

Each edge in the graph only stores its weight as a float. 

Definition at line \mbox{\hyperlink{a00200_source_l00099}{99}} of file \mbox{\hyperlink{a00200_source}{boost\+\_\+graph.\+h}}.



Collaboration diagram for HF\+::Pathfinding\+::Edge\+\_\+\+Cost\+:
% FIG 0
\begin{DoxyFields}{Class Members}
\mbox{\Hypertarget{a00472_aefea62ffa2c7078ac7d9f2eefaa96e07}\label{a00472_aefea62ffa2c7078ac7d9f2eefaa96e07}} 
float&
weight&
Cost of traversing this edge. \\
\hline

\end{DoxyFields}
\index{HF::Pathfinding::vertex\_data@{HF::Pathfinding::vertex\_data}}\label{a01379}
\Hypertarget{a00472_a01379}
\doxysubsubsection{struct HF\+::Pathfinding\+::vertex\+\_\+data}
Data stored for every vertex in the \mbox{\hyperlink{a01383}{Boost\+Graph}}. 

Every vertex stores in the graph stores it\textquotesingle{}s index p and a unique double d.

\begin{DoxyRefDesc}{Todo}
\item[\mbox{\hyperlink{a00452__todo000016}{Todo}}]Is the double d needed?\end{DoxyRefDesc}


Definition at line \mbox{\hyperlink{a00200_source_l00111}{111}} of file \mbox{\hyperlink{a00200_source}{boost\+\_\+graph.\+h}}.



Collaboration diagram for HF\+::Pathfinding\+::vertex\+\_\+data\+:
% FIG 1
\begin{DoxyFields}{Class Members}
\mbox{\Hypertarget{a00472_a3f23d92f8d538033cf4096201083944e}\label{a00472_a3f23d92f8d538033cf4096201083944e}} 
\mbox{\hyperlink{a00001_a02139}{double}}&
d&
Unknown may have been used for the colormap. \\
\hline

\mbox{\Hypertarget{a00472_a6d7facb34a520e63bf016898c8352648}\label{a00472_a6d7facb34a520e63bf016898c8352648}} 
graph\_traits$<$ compressed\_sparse\_row\_graph$<$ directedS $>$ $>$\mbox{\hyperlink{a00472_a4dc50f188646ed884b58b3e26c7932a5}{::vertex\_descriptor}}&
p&
The index of a vertex in the CSR. \\
\hline

\end{DoxyFields}


\doxysubsection{Typedef Documentation}
\mbox{\Hypertarget{a00472_a9314d552e0a8092644fa080c9945bd25}\label{a00472_a9314d552e0a8092644fa080c9945bd25}} 
\index{HF::Pathfinding@{HF::Pathfinding}!graph\_t@{graph\_t}}
\index{graph\_t@{graph\_t}!HF::Pathfinding@{HF::Pathfinding}}
\doxysubsubsection{\texorpdfstring{graph\_t}{graph\_t}}
{\footnotesize\ttfamily typedef boost\+::compressed\+\_\+sparse\+\_\+row\+\_\+graph$<$ boost\+::directedS, \mbox{\hyperlink{a00472_a01379}{vertex\+\_\+data}}, \mbox{\hyperlink{a00472_a01375}{Edge\+\_\+\+Cost}} $>$ \mbox{\hyperlink{a00472_a9314d552e0a8092644fa080c9945bd25}{HF\+::\+Pathfinding\+::graph\+\_\+t}}}



Type of graph held by the \mbox{\hyperlink{a01383}{Boost\+Graph}}. 

Set the graph as directed, store \mbox{\hyperlink{a00472_a01379}{vertex\+\_\+data}} for each vertex store \mbox{\hyperlink{a00472_a01375}{Edge\+\_\+\+Cost}} for each edge.

\begin{DoxyRemark}{Remarks}
By changing the contents of this typedef, you can change the type of graph that the \mbox{\hyperlink{a01383}{Boost\+Graph}} holds, and the the type of data stored for each vertex or edge.
\end{DoxyRemark}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{a00472_a01379}{vertex\+\_\+data}} for info on what every vertex in the graph holds. 

\mbox{\hyperlink{a00472_a01375}{Edge\+\_\+\+Cost}} for info on what every edge in the graph holds. 
\end{DoxySeeAlso}


Definition at line \mbox{\hyperlink{a00200_source_l00135}{135}} of file \mbox{\hyperlink{a00200_source}{boost\+\_\+graph.\+h}}.

\mbox{\Hypertarget{a00472_acc378c1e475802d96758aaef12d33dbc}\label{a00472_acc378c1e475802d96758aaef12d33dbc}} 
\index{HF::Pathfinding@{HF::Pathfinding}!pair@{pair}}
\index{pair@{pair}!HF::Pathfinding@{HF::Pathfinding}}
\doxysubsubsection{\texorpdfstring{pair}{pair}}
{\footnotesize\ttfamily typedef std\+::pair$<$int, int$>$ \mbox{\hyperlink{a00472_acc378c1e475802d96758aaef12d33dbc}{HF\+::\+Pathfinding\+::pair}}}



Shorten std\+::pair to simplify graph construction.  



Definition at line \mbox{\hyperlink{a00200_source_l00142}{142}} of file \mbox{\hyperlink{a00200_source}{boost\+\_\+graph.\+h}}.

\mbox{\Hypertarget{a00472_a4dc50f188646ed884b58b3e26c7932a5}\label{a00472_a4dc50f188646ed884b58b3e26c7932a5}} 
\index{HF::Pathfinding@{HF::Pathfinding}!vertex\_descriptor@{vertex\_descriptor}}
\index{vertex\_descriptor@{vertex\_descriptor}!HF::Pathfinding@{HF::Pathfinding}}
\doxysubsubsection{\texorpdfstring{vertex\_descriptor}{vertex\_descriptor}}
{\footnotesize\ttfamily typedef boost\+::graph\+\_\+traits$<$\mbox{\hyperlink{a00472_a9314d552e0a8092644fa080c9945bd25}{graph\+\_\+t}}$>$\+::vertex\+\_\+descriptor \mbox{\hyperlink{a00472_a4dc50f188646ed884b58b3e26c7932a5}{HF\+::\+Pathfinding\+::vertex\+\_\+descriptor}}}



Quick alias to shorten the typename of vertex descriptors for our graph\+\_\+t type. /summary\texorpdfstring{$>$}{>} 



Definition at line \mbox{\hyperlink{a00200_source_l00139}{139}} of file \mbox{\hyperlink{a00200_source}{boost\+\_\+graph.\+h}}.



\doxysubsection{Function Documentation}
\mbox{\Hypertarget{a00472_a9f6490539108da057db2486295458886}\label{a00472_a9f6490539108da057db2486295458886}} 
\index{HF::Pathfinding@{HF::Pathfinding}!BuildDistanceAndPredecessor@{BuildDistanceAndPredecessor}}
\index{BuildDistanceAndPredecessor@{BuildDistanceAndPredecessor}!HF::Pathfinding@{HF::Pathfinding}}
\doxysubsubsection{\texorpdfstring{BuildDistanceAndPredecessor()}{BuildDistanceAndPredecessor()}}
{\footnotesize\ttfamily \mbox{\hyperlink{a01387}{Dist\+Pred}} HF\+::\+Pathfinding\+::\+Build\+Distance\+And\+Predecessor (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{a00472_a9314d552e0a8092644fa080c9945bd25}{graph\+\_\+t}} \&}]{g,  }\item[{int}]{id }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Build a row of the distance and predecessor matrices for the node at id. 


\begin{DoxyParams}{Parameters}
{\em g} & Graph to build the predecessor and distance matrices for. \\
\hline
{\em id} & The node to generate the predecessor and distance matrix for.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A \mbox{\hyperlink{a01387}{Dist\+Pred}} containing the distance and predecessor arrays for ID in g. 
\end{DoxyReturn}


Definition at line \mbox{\hyperlink{a00203_source_l00146}{146}} of file \mbox{\hyperlink{a00203_source}{path\+\_\+finder.\+cpp}}.



References \mbox{\hyperlink{a00203_source_l00049}{HF\+::\+Pathfinding\+::\+Dist\+Pred\+::distance}}, \mbox{\hyperlink{a00203_source_l00050}{HF\+::\+Pathfinding\+::\+Dist\+Pred\+::predecessor}}, and \mbox{\hyperlink{a00200_source_l00100}{HF\+::\+Pathfinding\+::\+Edge\+\_\+\+Cost\+::weight}}.



Referenced by \mbox{\hyperlink{a00203_source_l00461}{Find\+APSP()}}, \mbox{\hyperlink{a00203_source_l00166}{Find\+Path()}}, \mbox{\hyperlink{a00203_source_l00178}{Find\+Paths()}}, and \mbox{\hyperlink{a00203_source_l00201}{Insert\+Paths\+Into\+Array()}}.

Here is the caller graph for this function\+:
% FIG 2
\mbox{\Hypertarget{a00472_a322ac32effd41c99359b82df0890e34a}\label{a00472_a322ac32effd41c99359b82df0890e34a}} 
\index{HF::Pathfinding@{HF::Pathfinding}!ConstructShortestPathFromPred@{ConstructShortestPathFromPred}}
\index{ConstructShortestPathFromPred@{ConstructShortestPathFromPred}!HF::Pathfinding@{HF::Pathfinding}}
\doxysubsubsection{\texorpdfstring{ConstructShortestPathFromPred()}{ConstructShortestPathFromPred()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{a02083}{Path}} HF\+::\+Pathfinding\+::\+Construct\+Shortest\+Path\+From\+Pred (\begin{DoxyParamCaption}\item[{int}]{start,  }\item[{int}]{end,  }\item[{const \mbox{\hyperlink{a01387}{Dist\+Pred}} \&}]{dist\+\_\+pred }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Overload to call this with a dist\+Pred instead of the raw arrays. 


\begin{DoxyParams}{Parameters}
{\em start} & Starting point of the path to generate. \\
\hline
{\em end} & End point of the path to generate. \\
\hline
{\em dist\+\_\+pred} & \mbox{\hyperlink{a01387}{Dist\+Pred}} containing the predecessor and distance matricies start. \\
\hline
\end{DoxyParams}


Definition at line \mbox{\hyperlink{a00203_source_l00133}{133}} of file \mbox{\hyperlink{a00203_source}{path\+\_\+finder.\+cpp}}.



References \mbox{\hyperlink{a00203_source_l00078}{Construct\+Shortest\+Path\+From\+Pred()}}, \mbox{\hyperlink{a00203_source_l00049}{HF\+::\+Pathfinding\+::\+Dist\+Pred\+::distance}}, and \mbox{\hyperlink{a00203_source_l00050}{HF\+::\+Pathfinding\+::\+Dist\+Pred\+::predecessor}}.

Here is the call graph for this function\+:
% FIG 3
\mbox{\Hypertarget{a00472_a977e4c93a977ab4e9e784d1e6fec79f4}\label{a00472_a977e4c93a977ab4e9e784d1e6fec79f4}} 
\index{HF::Pathfinding@{HF::Pathfinding}!ConstructShortestPathFromPred@{ConstructShortestPathFromPred}}
\index{ConstructShortestPathFromPred@{ConstructShortestPathFromPred}!HF::Pathfinding@{HF::Pathfinding}}
\doxysubsubsection{\texorpdfstring{ConstructShortestPathFromPred()}{ConstructShortestPathFromPred()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{a02083}{Path}} HF\+::\+Pathfinding\+::\+Construct\+Shortest\+Path\+From\+Pred (\begin{DoxyParamCaption}\item[{int}]{start,  }\item[{int}]{end,  }\item[{const std\+::vector$<$ size\+\_\+t $>$ \&}]{pred,  }\item[{const std\+::vector$<$ float $>$ \&}]{distances }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Construct the shortest path from start to end using the given predecessor and distance vectors. 


\begin{DoxyParams}{Parameters}
{\em start} & ID of the starting point. \\
\hline
{\em end} & ID of the end point. \\
\hline
{\em pred} & Predecessor matrix for the start node. \\
\hline
{\em distances} & Distance matrix for pred\\
\hline
\end{DoxyParams}
\begin{DoxyRefDesc}{Todo}
\item[\mbox{\hyperlink{a00452__todo000017}{Todo}}]Replace exception with an assert statment. It shouldn\textquotesingle{}t be triggered unless there\textquotesingle{}s a problem with this algorithm? \end{DoxyRefDesc}


Definition at line \mbox{\hyperlink{a00203_source_l00078}{78}} of file \mbox{\hyperlink{a00203_source}{path\+\_\+finder.\+cpp}}.



References \mbox{\hyperlink{a00278_source_l00012}{HF\+::\+Spatial\+Structures\+::\+Path\+::\+Add\+Node()}}, \mbox{\hyperlink{a00278_source_l00024}{HF\+::\+Spatial\+Structures\+::\+Path\+::\+Reverse()}}, and \mbox{\hyperlink{a00278_source_l00020}{HF\+::\+Spatial\+Structures\+::\+Path\+::size()}}.



Referenced by \mbox{\hyperlink{a00203_source_l00133}{Construct\+Shortest\+Path\+From\+Pred()}}, \mbox{\hyperlink{a00203_source_l00166}{Find\+Path()}}, \mbox{\hyperlink{a00203_source_l00178}{Find\+Paths()}}, and \mbox{\hyperlink{a00203_source_l00201}{Insert\+Paths\+Into\+Array()}}.

Here is the call graph for this function\+:
% FIG 4
Here is the caller graph for this function\+:
% FIG 5
\mbox{\Hypertarget{a00472_a3d6e0ea77f750fa05bbf4339584cc15a}\label{a00472_a3d6e0ea77f750fa05bbf4339584cc15a}} 
\index{HF::Pathfinding@{HF::Pathfinding}!ConstructShortestPathNodesFromPred@{ConstructShortestPathNodesFromPred}}
\index{ConstructShortestPathNodesFromPred@{ConstructShortestPathNodesFromPred}!HF::Pathfinding@{HF::Pathfinding}}
\doxysubsubsection{\texorpdfstring{ConstructShortestPathNodesFromPred()}{ConstructShortestPathNodesFromPred()}}
{\footnotesize\ttfamily std\+::vector$<$ int $>$ HF\+::\+Pathfinding\+::\+Construct\+Shortest\+Path\+Nodes\+From\+Pred (\begin{DoxyParamCaption}\item[{int}]{start,  }\item[{int}]{end,  }\item[{const std\+::vector$<$ size\+\_\+t $>$ \&}]{pred }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Construct the shortest path of node ids given predecessor and distance vectors. 


\begin{DoxyParams}{Parameters}
{\em start} & ID of the starting point. \\
\hline
{\em end} & ID of the end point. \\
\hline
{\em pred} & Predecessor matrix for the start node. \\
\hline
{\em distances} & Distance matrix for pred\\
\hline
\end{DoxyParams}
\begin{DoxyRefDesc}{Todo}
\item[\mbox{\hyperlink{a00452__todo000018}{Todo}}]Replace exception with an assert statment. It shouldn\textquotesingle{}t be triggered unless there\textquotesingle{}s a problem with this algorithm? \end{DoxyRefDesc}


Definition at line \mbox{\hyperlink{a00203_source_l00394}{394}} of file \mbox{\hyperlink{a00203_source}{path\+\_\+finder.\+cpp}}.



Referenced by \mbox{\hyperlink{a00203_source_l00461}{Find\+APSP()}}.

Here is the caller graph for this function\+:
% FIG 6
\mbox{\Hypertarget{a00472_ae2106e09eb44d681fbc6c0f66a3d3ac4}\label{a00472_ae2106e09eb44d681fbc6c0f66a3d3ac4}} 
\index{HF::Pathfinding@{HF::Pathfinding}!CreateBoostGraph@{CreateBoostGraph}}
\index{CreateBoostGraph@{CreateBoostGraph}!HF::Pathfinding@{HF::Pathfinding}}
\doxysubsubsection{\texorpdfstring{CreateBoostGraph()}{CreateBoostGraph()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{a01383}{Boost\+Graph}}, \mbox{\hyperlink{a01391}{Boost\+Graph\+Deleter}} $>$ HF\+::\+Pathfinding\+::\+Create\+Boost\+Graph (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{a01551}{HF\+::\+Spatial\+Structures\+::\+Graph}} \&}]{g,  }\item[{const std\+::string \&}]{cost\+\_\+type = {\ttfamily \char`\"{}\char`\"{}} }\end{DoxyParamCaption})}



Create a new boost graph from a \mbox{\hyperlink{a00465}{HF\+::\+Spatial\+Structures}}\+:Graph. 


\begin{DoxyParams}{Parameters}
{\em g} & The graph to create a \mbox{\hyperlink{a01383}{Boost\+Graph}} from \\
\hline
{\em cost\+\_\+type} & The name of the cost set in {\ttfamily graph} that will be used to construct this boost graph Leaving this as blank will use the cost type the graph was constructed with.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A unique\+\_\+ptr to point to the new \mbox{\hyperlink{a01383}{Boost\+Graph}} created from the HFGraph.
\end{DoxyReturn}
\begin{DoxyPrecond}{Precondition}
1) If {\ttfamily cost\+\_\+type} is specified, and is not an empty string, then {\ttfamily cost\+\_\+type} must be the key of an already created cost in {\ttfamily graph}. 

2) {\ttfamily graph} must be compressed.
\end{DoxyPrecond}
\begin{DoxyRemark}{Remarks}
This returns a pointer since it insulates the caller from needing to import Boost, which is extremely useful for the C\+\_\+\+Interface since its clients will not need to use boost at all and it doesn\textquotesingle{}t need to go through the trouble of compiling all of the boost library (again). A unique pointer was chosen here so the caller doesn\textquotesingle{}t need to worry about manually deleting the returned boost graph at a later point.
\end{DoxyRemark}

\begin{DoxyExceptions}{Exceptions}
{\em \mbox{\hyperlink{a01335}{HF\+::\+Exceptions\+::\+No\+Cost}}} & if {\ttfamily cost\+\_\+type} was not left blank and no cost type with the key {\ttfamily cost\+\_\+type} exists in {\ttfamily graph}.\\
\hline
\end{DoxyExceptions}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// be sure to \#include "{}path\_finder.h"{}, \#include "{}boost\_graph.h"{}, \#include "{}node.h"{},}}
\DoxyCodeLine{\textcolor{comment}{// \#include "{}graph.h"{}, and \#include <vector>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// For this example, we must have a BoostGraph instance to use with}}
\DoxyCodeLine{\textcolor{comment}{// BoostGraphDeleter. In order to create a BoostGraph, we must first create a Graph}}
\DoxyCodeLine{\textcolor{comment}{// instance first. We must prepare the nodes, their edges, and the weights}}
\DoxyCodeLine{\textcolor{comment}{// (distances) of each edge.}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Create the nodes}}
\DoxyCodeLine{\mbox{\hyperlink{a02071}{HF::SpatialStructures::Node}} node\_0(1.0f, 1.0f, 2.0f);}
\DoxyCodeLine{\mbox{\hyperlink{a02071}{HF::SpatialStructures::Node}} node\_1(2.0f, 3.0f, 4.0f, 5);}
\DoxyCodeLine{\mbox{\hyperlink{a02071}{HF::SpatialStructures::Node}} node\_2(11.0f, 22.0f, 140.0f);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Create a container (vector) of nodes}}
\DoxyCodeLine{std::vector<HF::SpatialStructures::Node> nodes = \{ node\_0, node\_1, node\_2 \};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Create matrices for edges and distances, edges.size() == distances().size()}}
\DoxyCodeLine{std::vector<std::vector<int>> edges = \{ \{ 1, 2 \}, \{ 2 \}, \{ 1 \} \};}
\DoxyCodeLine{std::vector<std::vector<float>> distances = \{ \{ 1.0f, 2.5f \}, \{ 54.0f \}, \{ 39.0f \} \};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Now you can create a Graph -\/ note that nodes, edges, and distances are passed by reference}}
\DoxyCodeLine{\mbox{\hyperlink{a01551}{HF::SpatialStructures::Graph}} graph(edges, distances, nodes);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Now we can create a smart pointer to a BoostGraph Note the type of boostGraph -\/}}
\DoxyCodeLine{\textcolor{comment}{// it is a std::unique\_ptr<HF::Pathfinding::BoostGraph,}}
\DoxyCodeLine{\textcolor{comment}{// HF::Pathfinding::BoostGraphDeleter>. Use the auto keyword for type inference, or}}
\DoxyCodeLine{\textcolor{comment}{// your choice of using statements/typedef to make the use of the type described}}
\DoxyCodeLine{\textcolor{comment}{// above easier.}}
\DoxyCodeLine{\textcolor{keyword}{auto} boostGraph = \mbox{\hyperlink{a00472_ae2106e09eb44d681fbc6c0f66a3d3ac4}{CreateBoostGraph}}(graph);}

\end{DoxyCode}
 

Definition at line \mbox{\hyperlink{a00203_source_l00320}{320}} of file \mbox{\hyperlink{a00203_source}{path\+\_\+finder.\+cpp}}.



Referenced by \mbox{\hyperlink{a00422_source_l00173}{Calculate\+Distance\+And\+Predecessor()}}, \mbox{\hyperlink{a00422_source_l00203}{Create\+All\+Pred\+To\+Path()}}, \mbox{\hyperlink{a00422_source_l00140}{Create\+All\+To\+All\+Paths()}}, \mbox{\hyperlink{a00422_source_l00025}{Create\+Path()}}, and \mbox{\hyperlink{a00422_source_l00072}{Create\+Paths()}}.

Here is the caller graph for this function\+:
% FIG 7
\mbox{\Hypertarget{a00472_abb65ba6c3ed7a1999d9f40ae14ba3269}\label{a00472_abb65ba6c3ed7a1999d9f40ae14ba3269}} 
\index{HF::Pathfinding@{HF::Pathfinding}!FindAllPaths@{FindAllPaths}}
\index{FindAllPaths@{FindAllPaths}!HF::Pathfinding@{HF::Pathfinding}}
\doxysubsubsection{\texorpdfstring{FindAllPaths()}{FindAllPaths()}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{a02083}{HF\+::\+Spatial\+Structures\+::\+Path}} $>$ HF\+::\+Pathfinding\+::\+Find\+All\+Paths (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{a01383}{Boost\+Graph}} $\ast$}]{bg }\end{DoxyParamCaption})}

Calculate a permutation for every combination of nodes in the graph, then call Find\+Paths, OR Write a unique function inspired by Find\+Paths that just runs through a range of paths.

\begin{DoxyRemark}{Remarks}
May benefit from using an algorithm optimized for this like \href{https://www.boost.org/doc/libs/1_73_0/libs/graph/doc/floyd_warshall_shortest.html}{\texttt{ https\+://www.\+boost.\+org/doc/libs/1\+\_\+73\+\_\+0/libs/graph/doc/floyd\+\_\+warshall\+\_\+shortest.\+html}}.
\end{DoxyRemark}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::out\+\_\+of\+\_\+memory} & if the memory required is too large.\\
\hline
\end{DoxyExceptions}
\begin{DoxyWarning}{Warning}
This will allocate a large amount of memory. Ensure that this won\textquotesingle{}t run out of memory when called, or be prepared to catch an out of memory exception. 
\end{DoxyWarning}
\begin{DoxyRefDesc}{Todo}
\item[\mbox{\hyperlink{a00452__todo000020}{Todo}}]Implement this function to the specifications outlined here. \end{DoxyRefDesc}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// NOTE: HF::Pathfinding::FindAllPaths is not implemented yet.}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// be sure to \#include "{}path\_finder.h"{}, \#include "{}boost\_graph.h"{}, and \#include "{}graph.h"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Create a Graph g, and compress it.}}
\DoxyCodeLine{\mbox{\hyperlink{a01551}{HF::SpatialStructures::Graph}} g;}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a37be5c12e488072dea7fa1c8c64346f7}{addEdge}}(0, 1, 1);}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a37be5c12e488072dea7fa1c8c64346f7}{addEdge}}(0, 2, 2);}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a37be5c12e488072dea7fa1c8c64346f7}{addEdge}}(1, 3, 3);}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a37be5c12e488072dea7fa1c8c64346f7}{addEdge}}(2, 4, 1);}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a37be5c12e488072dea7fa1c8c64346f7}{addEdge}}(3, 4, 5);}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a41cece77d0eee98df39ecc6d3a366ec8}{Compress}}();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Create a boostGraph from g}}
\DoxyCodeLine{\textcolor{keyword}{auto} boostGraph = \mbox{\hyperlink{a00472_ae2106e09eb44d681fbc6c0f66a3d3ac4}{HF::Pathfinding::CreateBoostGraph}}(g);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Get the path from node (id 0) to node (id 4)}}
\DoxyCodeLine{\textcolor{keyword}{auto} all\_paths = \mbox{\hyperlink{a00472_abb65ba6c3ed7a1999d9f40ae14ba3269}{HF::Pathfinding::FindAllPaths}}(boostGraph.get(), 0, 4);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// all\_paths will contain all shortest paths for [node 0, node 4]}}

\end{DoxyCode}
 \mbox{\Hypertarget{a00472_a6d24adcb1c0891a98e7d9a8d36f8cc01}\label{a00472_a6d24adcb1c0891a98e7d9a8d36f8cc01}} 
\index{HF::Pathfinding@{HF::Pathfinding}!FindAPSP@{FindAPSP}}
\index{FindAPSP@{FindAPSP}!HF::Pathfinding@{HF::Pathfinding}}
\doxysubsubsection{\texorpdfstring{FindAPSP()}{FindAPSP()}}
{\footnotesize\ttfamily std\+::vector$<$ std\+::vector$<$ int $>$ $>$ HF\+::\+Pathfinding\+::\+Find\+APSP (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{a01383}{Boost\+Graph}} \&}]{bg }\end{DoxyParamCaption})}



Definition at line \mbox{\hyperlink{a00203_source_l00461}{461}} of file \mbox{\hyperlink{a00203_source}{path\+\_\+finder.\+cpp}}.



References \mbox{\hyperlink{a00203_source_l00146}{Build\+Distance\+And\+Predecessor()}}, \mbox{\hyperlink{a00203_source_l00394}{Construct\+Shortest\+Path\+Nodes\+From\+Pred()}}, \mbox{\hyperlink{a00200_source_l00168}{HF\+::\+Pathfinding\+::\+Boost\+Graph\+::g}}, and \mbox{\hyperlink{a00200_source_l00169}{HF\+::\+Pathfinding\+::\+Boost\+Graph\+::p}}.



Referenced by \mbox{\hyperlink{a00422_source_l00203}{Create\+All\+Pred\+To\+Path()}}.

Here is the call graph for this function\+:
% FIG 8
Here is the caller graph for this function\+:
% FIG 9
\mbox{\Hypertarget{a00472_a47d06b1c4bd84f4d0a7519ea0e96ff02}\label{a00472_a47d06b1c4bd84f4d0a7519ea0e96ff02}} 
\index{HF::Pathfinding@{HF::Pathfinding}!FindPath@{FindPath}}
\index{FindPath@{FindPath}!HF::Pathfinding@{HF::Pathfinding}}
\doxysubsubsection{\texorpdfstring{FindPath()}{FindPath()}}
{\footnotesize\ttfamily \mbox{\hyperlink{a02083}{HF\+::\+Spatial\+Structures\+::\+Path}} HF\+::\+Pathfinding\+::\+Find\+Path (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{a01383}{Boost\+Graph}} $\ast$}]{bg,  }\item[{int}]{start\+\_\+id,  }\item[{int}]{end\+\_\+id }\end{DoxyParamCaption})}



Find a path between points A and B using Dijkstra\textquotesingle{}s Shortest Path algorithm.  


\begin{DoxyParams}{Parameters}
{\em bg} & The boost graph containing edges/nodes. \\
\hline
{\em start\+\_\+id} & ID of the starting node. \\
\hline
{\em end\+\_\+id} & ID of the ending node. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The shortest path between A and B. 
\end{DoxyReturn}


To find the path, A row of the predecessor matrix is generated for node a, then followed until node B is reached. This algorithm is implemented using dijkstra\+\_\+shortest\+\_\+path from the Boost\+Graph\+Library \href{https://www.boost.org/doc/libs/1_73_0/libs/graph/doc/dijkstra_shortest_paths_no_color_map.html}{\texttt{ https\+://www.\+boost.\+org/doc/libs/1\+\_\+73\+\_\+0/libs/graph/doc/dijkstra\+\_\+shortest\+\_\+paths\+\_\+no\+\_\+color\+\_\+map.\+html}}

\begin{DoxyNote}{Note}
Use Find\+Paths for multiple paths as it\textquotesingle{}s able to reuse a lot of work compared to running this in a loop.
\end{DoxyNote}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// be sure to \#include "{}path\_finder.h"{}, \#include "{}boost\_graph.h"{}, and \#include "{}graph.h"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Create a Graph g, and compress it.}}
\DoxyCodeLine{\mbox{\hyperlink{a01551}{HF::SpatialStructures::Graph}} g;}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a37be5c12e488072dea7fa1c8c64346f7}{addEdge}}(0, 1, 1);}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a37be5c12e488072dea7fa1c8c64346f7}{addEdge}}(0, 2, 2);}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a37be5c12e488072dea7fa1c8c64346f7}{addEdge}}(1, 3, 3);}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a37be5c12e488072dea7fa1c8c64346f7}{addEdge}}(2, 4, 1);}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a37be5c12e488072dea7fa1c8c64346f7}{addEdge}}(3, 4, 5);}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a41cece77d0eee98df39ecc6d3a366ec8}{Compress}}();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Create a boostGraph from g}}
\DoxyCodeLine{\textcolor{keyword}{auto} boostGraph = \mbox{\hyperlink{a00472_ae2106e09eb44d681fbc6c0f66a3d3ac4}{HF::Pathfinding::CreateBoostGraph}}(g);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Get the path from node (id 0) to node (id 3)}}
\DoxyCodeLine{\mbox{\hyperlink{a02083}{HF::SpatialStructures::Path}} path = \mbox{\hyperlink{a00472_a47d06b1c4bd84f4d0a7519ea0e96ff02}{HF::Pathfinding::FindPath}}(boostGraph.get(), 0, 3);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Print the nodes along the shortest path}}
\DoxyCodeLine{std::cout << \textcolor{stringliteral}{"{}Shortest path from node id 0 to node id 3:"{}} << std::endl;}
\DoxyCodeLine{\textcolor{keywordflow}{for} (\textcolor{keyword}{auto} p : path.\mbox{\hyperlink{a02083_a864cebbf4e5d7c135c501a63d42f8708}{members}}) \{}
\DoxyCodeLine{    std::cout << p.node << std::endl;}
\DoxyCodeLine{\}}

\end{DoxyCode}
 

Definition at line \mbox{\hyperlink{a00203_source_l00166}{166}} of file \mbox{\hyperlink{a00203_source}{path\+\_\+finder.\+cpp}}.



References \mbox{\hyperlink{a00203_source_l00146}{Build\+Distance\+And\+Predecessor()}}, \mbox{\hyperlink{a00203_source_l00078}{Construct\+Shortest\+Path\+From\+Pred()}}, and \mbox{\hyperlink{a00200_source_l00168}{HF\+::\+Pathfinding\+::\+Boost\+Graph\+::g}}.



Referenced by \mbox{\hyperlink{a00422_source_l00025}{Create\+Path()}}.

Here is the call graph for this function\+:
% FIG 10
Here is the caller graph for this function\+:
% FIG 11
\mbox{\Hypertarget{a00472_a15badb9d0a17849de7b21105605c9c91}\label{a00472_a15badb9d0a17849de7b21105605c9c91}} 
\index{HF::Pathfinding@{HF::Pathfinding}!FindPaths@{FindPaths}}
\index{FindPaths@{FindPaths}!HF::Pathfinding@{HF::Pathfinding}}
\doxysubsubsection{\texorpdfstring{FindPaths()}{FindPaths()}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{a02083}{HF\+::\+Spatial\+Structures\+::\+Path}} $>$ HF\+::\+Pathfinding\+::\+Find\+Paths (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{a01383}{Boost\+Graph}} $\ast$}]{bg,  }\item[{const std\+::vector$<$ int $>$ \&}]{start\+\_\+points,  }\item[{const std\+::vector$<$ int $>$ \&}]{end\+\_\+points }\end{DoxyParamCaption})}



Find a path from every id in start\+\_\+ids to the matching end node in end\+\_\+ids. 


\begin{DoxyParams}{Parameters}
{\em bg} & The boost graph containing edges/nodes. \\
\hline
{\em start\+\_\+points} & Ordered list of starting points. \\
\hline
{\em end\+\_\+points} & Ordered list of ending points.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
An ordered array of paths matching the order of the pairs of start\+\_\+id and end\+\_\+id. Paths that could not be generated will be returned as paths with no nodes.
\end{DoxyReturn}
More efficient than calling Find\+Path manually in a loop. Sorts paths by starting point, calculates only one predecessor matrix per unique starting point, then finds a path for every pair.

\begin{DoxyPrecond}{Precondition}
Length of start\+\_\+points must match that of end\+\_\+points.
\end{DoxyPrecond}
\begin{DoxyRefDesc}{Todo}
\item[\mbox{\hyperlink{a00452__todo000019}{Todo}}]This isn\textquotesingle{}t in parallel! Can be implemented using a similar approach to Insert\+Paths\+Into\+Array. \end{DoxyRefDesc}



\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// be sure to \#include "{}path\_finder.h"{}, \#include "{}boost\_graph.h"{}, and \#include "{}graph.h"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Create a Graph g, and compress it.}}
\DoxyCodeLine{\mbox{\hyperlink{a01551}{HF::SpatialStructures::Graph}} g;}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a37be5c12e488072dea7fa1c8c64346f7}{addEdge}}(0, 1, 1);}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a37be5c12e488072dea7fa1c8c64346f7}{addEdge}}(0, 2, 2);}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a37be5c12e488072dea7fa1c8c64346f7}{addEdge}}(1, 3, 3);}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a37be5c12e488072dea7fa1c8c64346f7}{addEdge}}(2, 4, 1);}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a37be5c12e488072dea7fa1c8c64346f7}{addEdge}}(3, 4, 5);}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a41cece77d0eee98df39ecc6d3a366ec8}{Compress}}();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Create a boostGraph from g}}
\DoxyCodeLine{\textcolor{keyword}{auto} boostGraph = \mbox{\hyperlink{a00472_ae2106e09eb44d681fbc6c0f66a3d3ac4}{HF::Pathfinding::CreateBoostGraph}}(g);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Prepare the parents and children vectors -\/-\/ We will be searching for the shortest}}
\DoxyCodeLine{\textcolor{comment}{// path from node 0 to node 3, as well as the shortest path from node 0 to node 4.}}
\DoxyCodeLine{std::vector<int> parents = \{ 0, 0 \};}
\DoxyCodeLine{std::vector<int> children = \{ 3, 4 \};}
\DoxyCodeLine{}
\DoxyCodeLine{std::vector<HF::SpatialStructures::Path> paths}
\DoxyCodeLine{    = \mbox{\hyperlink{a00472_a15badb9d0a17849de7b21105605c9c91}{HF::Pathfinding::FindPaths}}(boostGraph.get(), parents, children);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Get the shortest paths, which are already stored in paths}}
\DoxyCodeLine{\textcolor{keyword}{auto} path\_0\_3 = paths[0];}
\DoxyCodeLine{\textcolor{keyword}{auto} path\_0\_4 = paths[1];}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Print the shortest path from node 0 to node 3}}
\DoxyCodeLine{std::cout << \textcolor{stringliteral}{"{}Shortest path from node id 0 to node id 3:"{}} << std::endl;}
\DoxyCodeLine{\textcolor{keywordflow}{for} (\textcolor{keyword}{auto} p : path\_0\_3.members) \{}
\DoxyCodeLine{    std::cout << p.node << std::endl;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Print the shortest path from node 0 to node 4}}
\DoxyCodeLine{std::cout << \textcolor{stringliteral}{"{}Shortest path from node id 0 to node id 4:"{}} << std::endl;}
\DoxyCodeLine{\textcolor{keywordflow}{for} (\textcolor{keyword}{auto} p : path\_0\_4.members) \{}
\DoxyCodeLine{    std::cout << p.node << std::endl;}
\DoxyCodeLine{\}}

\end{DoxyCode}
 

Definition at line \mbox{\hyperlink{a00203_source_l00178}{178}} of file \mbox{\hyperlink{a00203_source}{path\+\_\+finder.\+cpp}}.



References \mbox{\hyperlink{a00203_source_l00146}{Build\+Distance\+And\+Predecessor()}}, \mbox{\hyperlink{a00203_source_l00078}{Construct\+Shortest\+Path\+From\+Pred()}}, and \mbox{\hyperlink{a00200_source_l00168}{HF\+::\+Pathfinding\+::\+Boost\+Graph\+::g}}.

Here is the call graph for this function\+:
% FIG 12
\mbox{\Hypertarget{a00472_ab58662be8e56c333d74d60a823e810e3}\label{a00472_ab58662be8e56c333d74d60a823e810e3}} 
\index{HF::Pathfinding@{HF::Pathfinding}!GenerateDistanceAndPred@{GenerateDistanceAndPred}}
\index{GenerateDistanceAndPred@{GenerateDistanceAndPred}!HF::Pathfinding@{HF::Pathfinding}}
\doxysubsubsection{\texorpdfstring{GenerateDistanceAndPred()}{GenerateDistanceAndPred()}}
{\footnotesize\ttfamily \mbox{\hyperlink{a01395}{Distance\+And\+Predecessor}} HF\+::\+Pathfinding\+::\+Generate\+Distance\+And\+Pred (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{a01383}{Boost\+Graph}} \&}]{bg }\end{DoxyParamCaption})}



Generate the distance and predecessor matricies for a specific boost graph. 


\begin{DoxyParams}{Parameters}
{\em bg} & Boost graph to generate the matricies from\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A \mbox{\hyperlink{a01395}{Distance\+And\+Predecessor}} containing pointers to the new distance and predecessor matricies
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
It is up to the caller to deallocate both arrays. This is mostly for the C\+\_\+\+Interface, and as such ignores the safety that most other functions adhere to. It is the caller\textquotesingle{}s responsibility to deallocate both arrays from this function.
\end{DoxyWarning}
\begin{DoxyParagraph}{Example}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Create a graph with some edges}}
\DoxyCodeLine{    Graph g;}
\DoxyCodeLine{}
\DoxyCodeLine{    vector<Node> nodes = \{}
\DoxyCodeLine{        Node(1,2,3), Node(4, 5, 6),}
\DoxyCodeLine{        Node(7, 8, 9), Node(10, 1, 2)}
\DoxyCodeLine{    \};}
\DoxyCodeLine{    g.addEdge(nodes[0], nodes[1], 10); g.addEdge(nodes[1], nodes[2], 20);}
\DoxyCodeLine{    g.addEdge(nodes[0], nodes[2], 5); g.addEdge(nodes[1], nodes[0], 10);}
\DoxyCodeLine{    g.Compress();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Turn it into a boost graph}}
\DoxyCodeLine{    \textcolor{keyword}{auto} bg = \mbox{\hyperlink{a00472_ae2106e09eb44d681fbc6c0f66a3d3ac4}{CreateBoostGraph}}(g);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Create distance/predecessor matricies from the boost graph}}
\DoxyCodeLine{    \textcolor{keyword}{auto} matricies = \mbox{\hyperlink{a00472_ab58662be8e56c333d74d60a823e810e3}{GenerateDistanceAndPred}}(*bg.get());}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// print output}}
\DoxyCodeLine{    std::cerr << \textcolor{stringliteral}{"{}DIST PRED "{}} << g.size() << std::endl;}
\DoxyCodeLine{    std::cerr << matricies << std::endl;}
\DoxyCodeLine{    }
\DoxyCodeLine{    \textcolor{comment}{// get matricies from the output}}
\DoxyCodeLine{    vector<float>* distance\_matrix = matricies.dist;}
\DoxyCodeLine{    vector<int>* predecessor\_matrix = matricies.pred;}
\DoxyCodeLine{}

\end{DoxyCodeInclude}
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Free them since it's our responsibility.}}
\DoxyCodeLine{    \textcolor{keyword}{delete} distance\_matrix;}
\DoxyCodeLine{    \textcolor{keyword}{delete} predecessor\_matrix;}
\DoxyCodeLine{    }

\end{DoxyCodeInclude}
 {\ttfamily \mbox{[}0.\+000000, 10.\+000000, 5.\+000000, 10.\+000000, 0.\+000000, 15.\+000000, -\/1.\+000000, -\/1.\+000000, 0.\+000000\mbox{]}}~\newline
{\ttfamily \mbox{[}0, 0, 0, 1, 1, 0, -\/1, -\/1, 2\mbox{]}} 
\end{DoxyParagraph}


Definition at line \mbox{\hyperlink{a00203_source_l00267}{267}} of file \mbox{\hyperlink{a00203_source}{path\+\_\+finder.\+cpp}}.



References \mbox{\hyperlink{a00200_source_l00168}{HF\+::\+Pathfinding\+::\+Boost\+Graph\+::g}}, \mbox{\hyperlink{a00206_source_l00437}{HF\+::\+Pathfinding\+::\+Distance\+And\+Predecessor\+::\+Get\+Row\+Of\+Dist()}}, \mbox{\hyperlink{a00206_source_l00451}{HF\+::\+Pathfinding\+::\+Distance\+And\+Predecessor\+::\+Get\+Row\+Of\+Pred()}}, \mbox{\hyperlink{a00200_source_l00169}{HF\+::\+Pathfinding\+::\+Boost\+Graph\+::p}}, and \mbox{\hyperlink{a00200_source_l00100}{HF\+::\+Pathfinding\+::\+Edge\+\_\+\+Cost\+::weight}}.



Referenced by \mbox{\hyperlink{a00422_source_l00173}{Calculate\+Distance\+And\+Predecessor()}}.

Here is the call graph for this function\+:
% FIG 13
Here is the caller graph for this function\+:
% FIG 14
\mbox{\Hypertarget{a00472_a496379e77c1c41453ef021358f8372fb}\label{a00472_a496379e77c1c41453ef021358f8372fb}} 
\index{HF::Pathfinding@{HF::Pathfinding}!GenerateDistanceAndPredFast@{GenerateDistanceAndPredFast}}
\index{GenerateDistanceAndPredFast@{GenerateDistanceAndPredFast}!HF::Pathfinding@{HF::Pathfinding}}
\doxysubsubsection{\texorpdfstring{GenerateDistanceAndPredFast()}{GenerateDistanceAndPredFast()}}
{\footnotesize\ttfamily \mbox{\hyperlink{a01395}{Distance\+And\+Predecessor}} HF\+::\+Pathfinding\+::\+Generate\+Distance\+And\+Pred\+Fast (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{a01383}{Boost\+Graph}} \&}]{bg }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\Hypertarget{a00472_a69bd3efcc13788e7c4be43b67d6002e5}\label{a00472_a69bd3efcc13788e7c4be43b67d6002e5}} 
\index{HF::Pathfinding@{HF::Pathfinding}!InsertAllToAllPathsIntoArray@{InsertAllToAllPathsIntoArray}}
\index{InsertAllToAllPathsIntoArray@{InsertAllToAllPathsIntoArray}!HF::Pathfinding@{HF::Pathfinding}}
\doxysubsubsection{\texorpdfstring{InsertAllToAllPathsIntoArray()}{InsertAllToAllPathsIntoArray()}}
{\footnotesize\ttfamily void HF\+::\+Pathfinding\+::\+Insert\+All\+To\+All\+Paths\+Into\+Array (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{a01383}{Boost\+Graph}} $\ast$}]{bg,  }\item[{\mbox{\hyperlink{a02083}{HF\+::\+Spatial\+Structures\+::\+Path}} $\ast$$\ast$}]{out\+\_\+paths,  }\item[{\mbox{\hyperlink{a02079}{HF\+::\+Spatial\+Structures\+::\+Path\+Member}} $\ast$$\ast$}]{out\+\_\+path\+\_\+members,  }\item[{int $\ast$}]{out\+\_\+sizes }\end{DoxyParamCaption})}



A special version of Find\+Paths optimized for the C\+\_\+\+Interface, such that all paths possible from each node to every other node are generated. 


\begin{DoxyParams}{Parameters}
{\em bg} & Boost graph to generate paths in \\
\hline
{\em out\+\_\+paths} & Location for the the path pointer array to be created. Paths that could not be generated will be left as null pointers. \\
\hline
{\em out\+\_\+path\+\_\+members} & Location for the pathmember pointer array will be created. All path member pointers will point to the Path\+Members of the Path in paths at the same location. Paths that could not be generated will be left as null pointers. \\
\hline
{\em out\+\_\+sizes} & Output raw\+\_\+array of integers that will cntain the length of every path in path\+\_\+members. Paths that could not be generated will be left with a length of zero.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
The length of start\+\_\+ids must match the length of end\+\_\+ids.
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
1) out\+\_\+path\+\_\+members will point to a vector of pointers to vectors of Path\+Members with an element for every path. 

2) out\+\_\+paths will point to a vector of pointers to paths with an element for every path. 

3) out\+\_\+sizes will point to an array of integers containing the size of every path in out\+\_\+paths
\end{DoxyPostcond}
\begin{DoxyRemark}{Remarks}
Usually the C-\/\+Interface is able to simply wrap existing functions with minimal code to make them accessible to exernal callers, however in this specific situation there were real performance gains to be found by implementing this function directly in HF\+::\+Path\+Finding itself. It\textquotesingle{}s efficent and safe for that purpose, but \mbox{\hyperlink{a00472_a15badb9d0a17849de7b21105605c9c91}{Find\+Paths}} should be preferred outside of that context since this function can be quite dangerous if not handled properly.
\end{DoxyRemark}
\begin{DoxyWarning}{Warning}
The caller is responsible for freeing all of the memory allocated in out\+\_\+paths and out\+\_\+sizes. The contents of out\+\_\+path\+\_\+members will automatically be deleted when the path they belong to is deleted. Do not try to manually delete out\+\_\+path\+\_\+members or the path that owns it will throw a null pointer exception when it is deleted.
\end{DoxyWarning}

\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{a01551}{HF::SpatialStructures::Graph}} g;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Add the edges}}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a37be5c12e488072dea7fa1c8c64346f7}{addEdge}}(0, 1, 1);}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a37be5c12e488072dea7fa1c8c64346f7}{addEdge}}(0, 2, 2);}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a37be5c12e488072dea7fa1c8c64346f7}{addEdge}}(1, 3, 3);}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a37be5c12e488072dea7fa1c8c64346f7}{addEdge}}(1, 4, 4);}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a37be5c12e488072dea7fa1c8c64346f7}{addEdge}}(2, 4, 4);}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a37be5c12e488072dea7fa1c8c64346f7}{addEdge}}(3, 5, 5);}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a37be5c12e488072dea7fa1c8c64346f7}{addEdge}}(4, 6, 3);}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a37be5c12e488072dea7fa1c8c64346f7}{addEdge}}(5, 6, 1);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Always compress the graph after adding edges}}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a41cece77d0eee98df39ecc6d3a366ec8}{Compress}}();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Create a BoostGraph (std::unique\_ptr)}}
\DoxyCodeLine{\textcolor{keyword}{auto} bg = \mbox{\hyperlink{a00472_ae2106e09eb44d681fbc6c0f66a3d3ac4}{CreateBoostGraph}}(g);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Total paths is node\_count \string^ 2}}
\DoxyCodeLine{\textcolor{keywordtype}{size\_t} node\_count = g.\mbox{\hyperlink{a01551_aa70347b8a33b57c6f0a72d6eca4248d7}{Nodes}}().size();}
\DoxyCodeLine{\textcolor{keywordtype}{size\_t} path\_count = node\_count * node\_count;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Pointer to buffer of (Path *)}}
\DoxyCodeLine{Path** out\_paths = \textcolor{keyword}{new} Path* [path\_count];}
\DoxyCodeLine{\textcolor{comment}{// out\_paths[i...path\_count -\/ 1] will be alloc'ed by InsertPathsIntoArray}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Pointer to buffer of (PathMember *)}}
\DoxyCodeLine{PathMember** out\_path\_member = \textcolor{keyword}{new} PathMember* [path\_count];}
\DoxyCodeLine{\textcolor{comment}{// out\_path\_member[i...path\_count -\/ 1] points to out\_paths[i...path\_count -\/ 1]-\/>GetPMPointer();}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Pointer to buffer of (int)}}
\DoxyCodeLine{\textcolor{keywordtype}{int}* sizes = \textcolor{keyword}{new} \textcolor{keywordtype}{int}[path\_count];}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//}}
\DoxyCodeLine{\textcolor{comment}{// The two loops for start\_points and end\_points}}
\DoxyCodeLine{\textcolor{comment}{// are just for the output.}}
\DoxyCodeLine{\textcolor{comment}{//}}
\DoxyCodeLine{\textcolor{keywordtype}{int} curr\_id = 0;}
\DoxyCodeLine{std::vector<int> start\_points(path\_count);}
\DoxyCodeLine{\textcolor{comment}{// Populate the start points,}}
\DoxyCodeLine{\textcolor{comment}{// size will be (node\_count)\string^2}}
\DoxyCodeLine{\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < node\_count; i++) \{}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k = 0; k < node\_count; k++) \{}
\DoxyCodeLine{        start\_points[curr\_id++] = i;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{curr\_id = 0;}
\DoxyCodeLine{}
\DoxyCodeLine{std::vector<int> end\_points(path\_count);}
\DoxyCodeLine{\textcolor{comment}{// Populate the end points,}}
\DoxyCodeLine{\textcolor{comment}{// size will be (node\_count)\string^2}}
\DoxyCodeLine{\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < node\_count; i++) \{}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k = 0; k < node\_count; k++) \{}
\DoxyCodeLine{        end\_points[curr\_id++] = k;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\mbox{\hyperlink{a00472_a69bd3efcc13788e7c4be43b67d6002e5}{InsertAllToAllPathsIntoArray}}(bg.get(), out\_paths, out\_path\_member, sizes);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < path\_count; i++) \{}
\DoxyCodeLine{    \textcolor{keywordflow}{if} (out\_paths[i]) \{}
\DoxyCodeLine{        \textcolor{comment}{// Always check if out\_paths[i] is nonnull!}}
\DoxyCodeLine{        \textcolor{keywordtype}{int} total\_cost = 0;}
\DoxyCodeLine{        std::cout << \textcolor{stringliteral}{"{}Path from "{}} << start\_points[i] << \textcolor{stringliteral}{"{} to "{}} << end\_points[i] << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{        Path p = *out\_paths[i];}
\DoxyCodeLine{        \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} m : p.members) \{}
\DoxyCodeLine{            total\_cost += m.cost;}
\DoxyCodeLine{            std::cout << \textcolor{stringliteral}{"{}node ID: "{}} << m.node << \textcolor{stringliteral}{"{}\(\backslash\)tcost "{}} << m.cost << std::endl;}
\DoxyCodeLine{        \}}
\DoxyCodeLine{}
\DoxyCodeLine{        std::cout << \textcolor{stringliteral}{"{}Total cost: "{}} << total\_cost << std::endl;}
\DoxyCodeLine{        std::cout << \textcolor{stringliteral}{"{}-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/"{}} << std::endl;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//}}
\DoxyCodeLine{\textcolor{comment}{// Resource cleanup}}
\DoxyCodeLine{\textcolor{comment}{//}}
\DoxyCodeLine{\textcolor{keywordflow}{if} (sizes) \{}
\DoxyCodeLine{    \textcolor{keyword}{delete}[] sizes;}
\DoxyCodeLine{    sizes = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordflow}{if} (out\_path\_member) \{}
\DoxyCodeLine{    \textcolor{keyword}{delete}[] out\_path\_member;}
\DoxyCodeLine{    out\_path\_member = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordflow}{if} (out\_paths) \{}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < path\_count; i++) \{}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (out\_paths[i]) \{}
\DoxyCodeLine{            \textcolor{keyword}{delete} out\_paths[i];}
\DoxyCodeLine{            out\_paths[i] = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{        \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
 

Definition at line \mbox{\hyperlink{a00203_source_l00329}{329}} of file \mbox{\hyperlink{a00203_source}{path\+\_\+finder.\+cpp}}.



References \mbox{\hyperlink{a00203_source_l00201}{Insert\+Paths\+Into\+Array()}}, and \mbox{\hyperlink{a00200_source_l00169}{HF\+::\+Pathfinding\+::\+Boost\+Graph\+::p}}.



Referenced by \mbox{\hyperlink{a00422_source_l00140}{Create\+All\+To\+All\+Paths()}}.

Here is the call graph for this function\+:
% FIG 15
Here is the caller graph for this function\+:
% FIG 16
\mbox{\Hypertarget{a00472_a417084c97d0672af2da7739157a9d8c0}\label{a00472_a417084c97d0672af2da7739157a9d8c0}} 
\index{HF::Pathfinding@{HF::Pathfinding}!InsertPathsIntoArray@{InsertPathsIntoArray}}
\index{InsertPathsIntoArray@{InsertPathsIntoArray}!HF::Pathfinding@{HF::Pathfinding}}
\doxysubsubsection{\texorpdfstring{InsertPathsIntoArray()}{InsertPathsIntoArray()}}
{\footnotesize\ttfamily void HF\+::\+Pathfinding\+::\+Insert\+Paths\+Into\+Array (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{a01383}{Boost\+Graph}} $\ast$}]{bg,  }\item[{const std\+::vector$<$ int $>$ \&}]{start\+\_\+points,  }\item[{const std\+::vector$<$ int $>$ \&}]{end\+\_\+points,  }\item[{\mbox{\hyperlink{a02083}{HF\+::\+Spatial\+Structures\+::\+Path}} $\ast$$\ast$}]{out\+\_\+paths,  }\item[{\mbox{\hyperlink{a02079}{HF\+::\+Spatial\+Structures\+::\+Path\+Member}} $\ast$$\ast$}]{out\+\_\+path\+\_\+members,  }\item[{int $\ast$}]{out\+\_\+sizes }\end{DoxyParamCaption})}



A special version of Find\+Paths optimized for the C\+\_\+\+Interface. 


\begin{DoxyParams}{Parameters}
{\em bg} & Boost graph to generate paths in \\
\hline
{\em start\+\_\+points} & An ordered list of start points to generate paths from. \\
\hline
{\em end\+\_\+points} & An ordered list of end points to generate paths to. \\
\hline
{\em out\+\_\+paths} & Location for the the path pointer array to be created. Paths that could not be generated will be left as null pointers. \\
\hline
{\em out\+\_\+path\+\_\+members} & Location for the pathmember pointer array will be created. All path member pointers will point to the Path\+Members of the Path in paths at the same location. Paths that could not be generated will be left as null pointers. \\
\hline
{\em out\+\_\+sizes} & Output raw\+\_\+array of integers that will contain the length of every path in path\+\_\+members. Paths that could not be generated will be left with a length of zero.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
The length of start\+\_\+ids must match the length of end\+\_\+ids.
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
1) out\+\_\+path\+\_\+members will point to a vector of pointers to vectors of Path\+Members with an element for every path. 

2) out\+\_\+paths will point to a vector of pointers to paths with an element for every path. 

3) out\+\_\+sizes will point to an array of integers containing the size of every path in out\+\_\+paths
\end{DoxyPostcond}
\begin{DoxyRemark}{Remarks}
Usually the C-\/\+Interface is able to simply wrap existing functions with minimal code to make them accessible to exernal callers, however in this specific situation there were real performance gains to be found by implementing this function directly in HF\+::\+Path\+Finding itself. It\textquotesingle{}s efficent and safe for that purpose, but \mbox{\hyperlink{a00472_a15badb9d0a17849de7b21105605c9c91}{Find\+Paths}} should be preferred outside of that context since this function can be quite dangerous if not handled properly.
\end{DoxyRemark}
\begin{DoxyWarning}{Warning}
The caller is responsible for freeing all of the memory allocated in out\+\_\+paths and out\+\_\+sizes. The contents of out\+\_\+path\+\_\+members will automatically be deleted when the path they belong to is deleted. Do not try to manually delete out\+\_\+path\+\_\+members or the path that owns it will throw a null pointer exception when it is deleted.
\end{DoxyWarning}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// be sure to \#include "{}path\_finder.h"{}, \#include "{}boost\_graph.h"{}, and \#include "{}graph.h"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Create a Graph g, and compress it.}}
\DoxyCodeLine{\mbox{\hyperlink{a01551}{HF::SpatialStructures::Graph}} g;}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a37be5c12e488072dea7fa1c8c64346f7}{addEdge}}(0, 1, 1);}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a37be5c12e488072dea7fa1c8c64346f7}{addEdge}}(0, 2, 2);}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a37be5c12e488072dea7fa1c8c64346f7}{addEdge}}(1, 3, 3);}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a37be5c12e488072dea7fa1c8c64346f7}{addEdge}}(2, 4, 1);}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a37be5c12e488072dea7fa1c8c64346f7}{addEdge}}(3, 4, 5);}
\DoxyCodeLine{g.\mbox{\hyperlink{a01551_a41cece77d0eee98df39ecc6d3a366ec8}{Compress}}();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Create a boostGraph from g}}
\DoxyCodeLine{\textcolor{keyword}{auto} boostGraph = \mbox{\hyperlink{a00472_ae2106e09eb44d681fbc6c0f66a3d3ac4}{HF::Pathfinding::CreateBoostGraph}}(g);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Prepare the parents and children vectors -\/-\/ We will be searching for the shortest}}
\DoxyCodeLine{\textcolor{comment}{// path from node 0 to node 3, as well as the shortest path from node 0 to node 4.}}
\DoxyCodeLine{std::vector<int> parents = \{ 0, 0 \};}
\DoxyCodeLine{std::vector<int> children = \{ 3, 4 \};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Create smart pointers to hold Path, PathMember and sizes}}
\DoxyCodeLine{\textcolor{keyword}{const} \textcolor{keywordtype}{int} MAX\_SIZE = 4;}
\DoxyCodeLine{std::unique\_ptr<HF::SpatialStructures::Path[]> result\_paths(\textcolor{keyword}{new} Path[MAX\_SIZE]);}
\DoxyCodeLine{std::unique\_ptr<HF::SpatialStructures::PathMember[]> result\_path\_members(\textcolor{keyword}{new} PathMember[MAX\_SIZE]);}
\DoxyCodeLine{std::unique\_ptr<int[]> result\_sizes(\textcolor{keyword}{new} \textcolor{keywordtype}{int}[MAX\_SIZE]);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Retrieve raw pointers so their addresses can be passed to InsertPathsIntoArray}}
\DoxyCodeLine{\mbox{\hyperlink{a02083}{HF::SpatialStructures::Path}}* ppath = result\_paths.get();}
\DoxyCodeLine{\mbox{\hyperlink{a02079}{HF::SpatialStructures::PathMember}}* pmembers = result\_path\_members.get();}
\DoxyCodeLine{\textcolor{keywordtype}{int}* psizes = result\_sizes.get();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Use InsertPathsIntoArray}}
\DoxyCodeLine{\mbox{\hyperlink{a00472_a417084c97d0672af2da7739157a9d8c0}{HF::Pathfinding::InsertPathsIntoArray}}(boostGraph.get(), parents, children, \&ppath, \&pmembers, psizes);}

\end{DoxyCode}
 

Definition at line \mbox{\hyperlink{a00203_source_l00201}{201}} of file \mbox{\hyperlink{a00203_source}{path\+\_\+finder.\+cpp}}.



References \mbox{\hyperlink{a00203_source_l00146}{Build\+Distance\+And\+Predecessor()}}, \mbox{\hyperlink{a00203_source_l00078}{Construct\+Shortest\+Path\+From\+Pred()}}, \mbox{\hyperlink{a00200_source_l00168}{HF\+::\+Pathfinding\+::\+Boost\+Graph\+::g}}, \mbox{\hyperlink{a00278_source_l00056}{HF\+::\+Spatial\+Structures\+::\+Path\+::\+Get\+PMPointer()}}, and \mbox{\hyperlink{a00278_source_l00020}{HF\+::\+Spatial\+Structures\+::\+Path\+::size()}}.



Referenced by \mbox{\hyperlink{a00422_source_l00072}{Create\+Paths()}}, and \mbox{\hyperlink{a00203_source_l00329}{Insert\+All\+To\+All\+Paths\+Into\+Array()}}.

Here is the call graph for this function\+:
% FIG 17
Here is the caller graph for this function\+:
% FIG 18
