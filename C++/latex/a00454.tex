\hypertarget{a00454}{}\doxysection{Graph\+Generator}
\label{a00454}\index{GraphGenerator@{GraphGenerator}}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{a00407_a91fa3b2bb3a7312ec39d74cc1fbc7bbe}{C\+\_\+\+INTERFACE}} \mbox{\hyperlink{a00454_ga2df84a732d1edfb70b7bd26d3282e129}{Generate\+Graph}} (\mbox{\hyperlink{a01411}{HF\+::\+Ray\+Tracer\+::\+Embree\+Ray\+Tracer}} $\ast$ray\+\_\+tracer, const float $\ast$start\+\_\+point, const float $\ast$spacing, int Max\+Nodes, float Up\+Step, float Up\+Slope, float Down\+Step, float Down\+Slope, int max\+\_\+step\+\_\+connection, int min\+\_\+connections, int core\+\_\+count, \mbox{\hyperlink{a01551}{HF\+::\+Spatial\+Structures\+::\+Graph}} $\ast$$\ast$out\+\_\+graph)
\begin{DoxyCompactList}\small\item\em Construct a graph by performing a breadth-\/first search of accessible space. \end{DoxyCompactList}\item 
\mbox{\hyperlink{a00407_a91fa3b2bb3a7312ec39d74cc1fbc7bbe}{C\+\_\+\+INTERFACE}} \mbox{\hyperlink{a00454_gab9f58e3ecc686fa9bc34519b0faed734}{Generate\+Graph\+Obstacles}} (\mbox{\hyperlink{a01411}{HF\+::\+Ray\+Tracer\+::\+Embree\+Ray\+Tracer}} $\ast$ray\+\_\+tracer, const float $\ast$start\+\_\+point, const float $\ast$spacing, int Max\+Nodes, float Up\+Step, float Up\+Slope, float Down\+Step, float Down\+Slope, int max\+\_\+step\+\_\+connection, int min\+\_\+connections, int core\+\_\+count, const int $\ast$obstacle\+\_\+ids, const int $\ast$walkable\+\_\+ids, int num\+\_\+obstacles, int num\+\_\+walkables, \mbox{\hyperlink{a01551}{HF\+::\+Spatial\+Structures\+::\+Graph}} $\ast$$\ast$out\+\_\+graph)
\begin{DoxyCompactList}\small\item\em Construct a graph by performing a breadth-\/first search of accessible space, seperating obstacles from walkable geometry. \end{DoxyCompactList}\item 
\mbox{\hyperlink{a00407_a91fa3b2bb3a7312ec39d74cc1fbc7bbe}{C\+\_\+\+INTERFACE}} \mbox{\hyperlink{a00454_gae7f55e49ba1992471430d0e3d415ebae}{Calculate\+And\+Store\+Step\+Types}} (\mbox{\hyperlink{a01551}{HF\+::\+Spatial\+Structures\+::\+Graph}} $\ast$g, \mbox{\hyperlink{a01411}{HF\+::\+Ray\+Tracer\+::\+Embree\+Ray\+Tracer}} $\ast$ray\+\_\+tracer)
\begin{DoxyCompactList}\small\item\em Query the graph and identify the step types of all edges, adding them to the graph. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Perform a breadth-\/first search on a mesh to find accessible space. 

\doxysubsection{Function Documentation}
\mbox{\Hypertarget{a00454_gae7f55e49ba1992471430d0e3d415ebae}\label{a00454_gae7f55e49ba1992471430d0e3d415ebae}} 
\index{GraphGenerator@{GraphGenerator}!CalculateAndStoreStepTypes@{CalculateAndStoreStepTypes}}
\index{CalculateAndStoreStepTypes@{CalculateAndStoreStepTypes}!GraphGenerator@{GraphGenerator}}
\doxysubsubsection{\texorpdfstring{CalculateAndStoreStepTypes()}{CalculateAndStoreStepTypes()}}
{\footnotesize\ttfamily \mbox{\hyperlink{a00407_a91fa3b2bb3a7312ec39d74cc1fbc7bbe}{C\+\_\+\+INTERFACE}} Calculate\+And\+Store\+Step\+Types (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{a01551}{HF\+::\+Spatial\+Structures\+::\+Graph}} $\ast$}]{g,  }\item[{\mbox{\hyperlink{a01411}{HF\+::\+Ray\+Tracer\+::\+Embree\+Ray\+Tracer}} $\ast$}]{ray\+\_\+tracer }\end{DoxyParamCaption})}



{\ttfamily \#include $<$\mbox{\hyperlink{a00407}{Cinterface/analysis\+\_\+\+C.\+h}}$>$}



Query the graph and identify the step types of all edges, adding them to the graph. 


\begin{DoxyParams}{Parameters}
{\em g} & Graph used to query step types.\\
\hline
{\em ray\+\_\+tracer} & Raytracer containing the geometry to use for graph generation.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{}{HF\+\_\+\+STATUS\+::\+OK}} if query was successful and edges corresponding to step types have been added to the graph. 
\end{DoxyReturn}


Definition at line \mbox{\hyperlink{a00404_source_l00109}{109}} of file \mbox{\hyperlink{a00404_source}{analysis\+\_\+\+C.\+cpp}}.



References \mbox{\hyperlink{a01551_a6f04c5320d4bf88120f8c5e31b0fb02a}{HF\+::\+Spatial\+Structures\+::\+Graph\+::\+Add\+Edges()}}, \mbox{\hyperlink{a00011_source_l00303}{HF\+::\+Graph\+Generator\+::\+Calculate\+Step\+Type()}}, \mbox{\hyperlink{a01551_a41cece77d0eee98df39ecc6d3a366ec8}{HF\+::\+Spatial\+Structures\+::\+Graph\+::\+Compress()}}, and \mbox{\hyperlink{a00176_source_l00032}{HF\+::\+Exceptions\+::\+OK}}.

Here is the call graph for this function\+:
% FIG 0
\mbox{\Hypertarget{a00454_ga2df84a732d1edfb70b7bd26d3282e129}\label{a00454_ga2df84a732d1edfb70b7bd26d3282e129}} 
\index{GraphGenerator@{GraphGenerator}!GenerateGraph@{GenerateGraph}}
\index{GenerateGraph@{GenerateGraph}!GraphGenerator@{GraphGenerator}}
\doxysubsubsection{\texorpdfstring{GenerateGraph()}{GenerateGraph()}}
{\footnotesize\ttfamily \mbox{\hyperlink{a00407_a91fa3b2bb3a7312ec39d74cc1fbc7bbe}{C\+\_\+\+INTERFACE}} Generate\+Graph (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{a01411}{HF\+::\+Ray\+Tracer\+::\+Embree\+Ray\+Tracer}} $\ast$}]{ray\+\_\+tracer,  }\item[{const float $\ast$}]{start\+\_\+point,  }\item[{const float $\ast$}]{spacing,  }\item[{int}]{Max\+Nodes,  }\item[{float}]{Up\+Step,  }\item[{float}]{Up\+Slope,  }\item[{float}]{Down\+Step,  }\item[{float}]{Down\+Slope,  }\item[{int}]{max\+\_\+step\+\_\+connection,  }\item[{int}]{min\+\_\+connections,  }\item[{int}]{core\+\_\+count,  }\item[{\mbox{\hyperlink{a01551}{HF\+::\+Spatial\+Structures\+::\+Graph}} $\ast$$\ast$}]{out\+\_\+graph }\end{DoxyParamCaption})}



{\ttfamily \#include $<$\mbox{\hyperlink{a00407}{Cinterface/analysis\+\_\+\+C.\+h}}$>$}



Construct a graph by performing a breadth-\/first search of accessible space. 


\begin{DoxyParams}{Parameters}
{\em ray\+\_\+tracer} & Raytracer containing the geometry to use for graph generation.\\
\hline
{\em start\+\_\+point} & The starting point for the graph generator to begin searching from. If this isn\textquotesingle{}t above solid ground, no nodes will be generated.\\
\hline
{\em spacing} & Space between nodes for each step of the search. Lower values will yield more nodes for a higher resolution graph.\\
\hline
{\em Max\+Nodes} & Stop generation after this many nodes. A value of -\/1 will generate an infinite amount of nodes. Note that the final node count may be greater than this value.\\
\hline
{\em Up\+Step} & Maximum height of a step the graph can traverse. Any steps higher this will be considered inaccessible.\\
\hline
{\em Up\+Slope} & Maximum upward slope the graph can traverse in degrees. Any slopes steeper than this will be considered inaccessible.\\
\hline
{\em Down\+Step} & Maximum step down the graph can traverse. Any steps steeper than this will be considered inaccessible.\\
\hline
{\em Down\+Slope} & The maximum downward slope the graph can traverse. Any slopes steeper than this will be considered inaccessible.\\
\hline
{\em max\+\_\+step\+\_\+connection} & Multiplier for number of children to generate for each node. Increasing this value will increase the number of edges in the graph, and as a result the amount of memory the algorithm requires.\\
\hline
{\em min\+\_\+connections} & The required out-\/degree for a node to be valid and stored. This must be greater than 0 and equal or less than the total connections created from max\+\_\+step\+\_\+connections. Default is 1. A value of 8 when max\+\_\+step\+\_\+connections=1 would be a grid.\\
\hline
{\em core\+\_\+count} & Number of cores to use. -\/1 will use all available cores, and 0 or 1 will run a serialized version of the algorithm.\\
\hline
{\em out\+\_\+graph} & Address of a (\mbox{\hyperlink{a01551}{HF\+::\+Spatial\+Structures\+::\+Graph}} $\ast$); out\+\_\+graph will address heap-\/allocated memory to an initialized \mbox{\hyperlink{a01551}{HF\+::\+Spatial\+Structures\+::\+Graph}} on success.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{}{HF\+\_\+\+STATUS\+::\+OK}} if graph creation was successful. \mbox{\hyperlink{}{HF\+\_\+\+STATUS\+::\+NO\+\_\+\+GRAPH}} if \mbox{\hyperlink{a00454_ga2df84a732d1edfb70b7bd26d3282e129}{Generate\+Graph}} failed to generate a graph with more than a single node.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{a00457_raytracer_setup}{Raytracer setup}} (how to create a BVH), \mbox{\hyperlink{a00457_raytracer_teardown}{Raytracer teardown}} (how to destroy a BVH)
\end{DoxySeeAlso}
You must {\bfseries{load an .obj file}} and {\bfseries{create a BVH}} first.~\newline
 Begin by reviewing the example at \mbox{\hyperlink{a00457_raytracer_setup}{Raytracer setup}} before proceeding below.

First, determine the {\bfseries{start point}}, {\bfseries{spacing of nodes for each axis}}, and {\bfseries{maximum nodes to generate}}.~\newline
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{// Define start point.}}
\DoxyCodeLine{        \textcolor{comment}{// These are Cartesian coordinates.}}
\DoxyCodeLine{        std::array<float, 3> start\_point \{ -\/1.0f, -\/6.0f, 1623.976928f \};}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// Define spacing.}}
\DoxyCodeLine{        \textcolor{comment}{// This is the spacing between nodes, with respect to each axis.}}
\DoxyCodeLine{        std::array<float, 3> spacing \{ 0.5f, 0.5f, 0.5f \};}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// Set max nodes.}}
\DoxyCodeLine{        \textcolor{keyword}{const} \textcolor{keywordtype}{int} max\_nodes = 500;}

\end{DoxyCodeInclude}


Then, determine the remainder of the values required by \mbox{\hyperlink{a00454_ga2df84a732d1edfb70b7bd26d3282e129}{Generate\+Graph}} before calling it.~\newline
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{// Generate graph.}}
\DoxyCodeLine{        \textcolor{comment}{// Notice that we pass the address of the graph pointer into GenerateGraph.}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// GenerateGraph will assign the deferenced address to a pointer that points}}
\DoxyCodeLine{        \textcolor{comment}{// to memory on the free store. We will call DestroyGraph to release the memory resources later on.}}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordtype}{float} up\_step = 1;                      \textcolor{comment}{// maximum height of a step the graph can traverse}}
\DoxyCodeLine{        \textcolor{keywordtype}{float} up\_slope = 1;                     \textcolor{comment}{// maximum upward slope the graph can traverse in degrees}}
\DoxyCodeLine{        \textcolor{keywordtype}{float} down\_step = 1;                    \textcolor{comment}{// maximum step down that the graph can traverse}}
\DoxyCodeLine{        \textcolor{keywordtype}{float} down\_slope = 1;                   \textcolor{comment}{// maximum downward slope that the graph can traverse}}
\DoxyCodeLine{        \textcolor{keywordtype}{int} maximum\_step\_connection = 1;        \textcolor{comment}{// multiplier for number of children to generate for each node}}
\DoxyCodeLine{        \textcolor{keywordtype}{int} core\_count = -\/1;                    \textcolor{comment}{// CPU core count, -\/1 uses all available cores on the machine}}
\DoxyCodeLine{}
\DoxyCodeLine{        \mbox{\hyperlink{a01551}{HF::SpatialStructures::Graph}}* graph = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{}
\DoxyCodeLine{        status = \mbox{\hyperlink{a00454_ga2df84a732d1edfb70b7bd26d3282e129}{GenerateGraph}}(bvh,}
\DoxyCodeLine{            start\_point.data(), spacing.data(), max\_nodes,}
\DoxyCodeLine{            up\_step, up\_slope,}
\DoxyCodeLine{            down\_step, down\_slope,}
\DoxyCodeLine{            maximum\_step\_connection,}
\DoxyCodeLine{            core\_count,}
\DoxyCodeLine{            \&graph);}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (status != 1) \{}
\DoxyCodeLine{            \textcolor{comment}{// Error!}}
\DoxyCodeLine{            std::cerr << \textcolor{stringliteral}{"{}Error at GenerateGraph, code: "{}} << status << std::endl;}
\DoxyCodeLine{        \}}

\end{DoxyCodeInclude}


{\bfseries{Very important!}} {\bfseries{Compress the graph}} after generating a graph or adding edges.~\newline
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{// Always compress the graph after generating a graph/adding new edges}}
\DoxyCodeLine{        status = \mbox{\hyperlink{a00458_gab7ecc1be5c746ed3f99ab7494316c65d}{Compress}}(graph);}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (status != 1) \{}
\DoxyCodeLine{            \textcolor{comment}{// Error!}}
\DoxyCodeLine{            std::cerr << \textcolor{stringliteral}{"{}Error at Compress, code: "{}} << status << std::endl;}
\DoxyCodeLine{        \}}

\end{DoxyCodeInclude}


To output the graph to the console, we must {\bfseries{retrieve its nodes}}.~\newline
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{// Get all nodes from graph first (the container of nodes)}}
\DoxyCodeLine{        \textcolor{comment}{// The address of the local variable node\_vector will be passed to GetAllNodesFromGraph;}}
\DoxyCodeLine{        \textcolor{comment}{// it will be dereferenced inside that function and assigned memory via operator new.}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// We will have to call DestroyNodes on node\_vector to properly release this memory.}}
\DoxyCodeLine{        \textcolor{comment}{// node\_vector\_data points to the internal buffer that resides within *(node\_vector).}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// When we call DestroyNodes, node\_vector\_data's memory will also be released.}}
\DoxyCodeLine{        std::vector<HF::SpatialStructures::Node>* node\_vector = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{        \mbox{\hyperlink{a02071}{HF::SpatialStructures::Node}}* node\_vector\_data = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{}
\DoxyCodeLine{        status = \mbox{\hyperlink{a00458_ga0cc5b82caab046c65a201e4e7be5e9d4}{GetAllNodesFromGraph}}(graph, \&node\_vector, \&node\_vector\_data);}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (status != 1) \{}
\DoxyCodeLine{            \textcolor{comment}{// Error!}}
\DoxyCodeLine{            std::cerr << \textcolor{stringliteral}{"{}Error at GetAllNodesFromGraph, code: "{}} << status << std::endl;}
\DoxyCodeLine{        \}}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// Get size of node vector}}
\DoxyCodeLine{        \textcolor{keywordtype}{int} node\_vector\_size = -\/1;}
\DoxyCodeLine{        status = \mbox{\hyperlink{a00458_gac17c1fc05e6bf6900bac8689b7619bfb}{GetSizeOfNodeVector}}(node\_vector, \&node\_vector\_size);}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (status != 1) \{}
\DoxyCodeLine{            \textcolor{comment}{// Error!}}
\DoxyCodeLine{            std::cerr << \textcolor{stringliteral}{"{}Error at GetSizeOfNodeVector, code: "{}} << status << std::endl;}
\DoxyCodeLine{        \}}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// Print number of nodes in the graph}}
\DoxyCodeLine{        std::cout << \textcolor{stringliteral}{"{}Node count: "{}} << node\_vector\_size << std::endl;}

\end{DoxyCodeInclude}


We are now ready to {\bfseries{output}} the generated graph to the {\bfseries{console}}.~\newline
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{// Output 3 of the nodes within *node\_vector.}}
\DoxyCodeLine{        std::cout << \textcolor{stringliteral}{"{}["{}};}
\DoxyCodeLine{        \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 3; i++) \{}
\DoxyCodeLine{            \textcolor{keyword}{auto} n = (*node\_vector)[i];}
\DoxyCodeLine{            std::cout << \textcolor{stringliteral}{"{}("{}}}
\DoxyCodeLine{                << n.x << \textcolor{stringliteral}{"{}, "{}} << n.y << \textcolor{stringliteral}{"{}, "{}} << n.z << \textcolor{stringliteral}{"{}, "{}}}
\DoxyCodeLine{                << n.id << \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{keywordflow}{if} (i < 2) \{}
\DoxyCodeLine{                std::cout << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{            \}}
\DoxyCodeLine{        \}}
\DoxyCodeLine{        std::cout << \textcolor{stringliteral}{"{}]"{}} << std::endl;}

\end{DoxyCodeInclude}


When we are finished, we must destroy {\bfseries{node\+\_\+vector}} and {\bfseries{graph}}.~\newline
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// destroy vector<Node>}}
\DoxyCodeLine{        status = \mbox{\hyperlink{a00458_ga87e9b9ecfc5293712d75f3cb8c992c77}{DestroyNodes}}(node\_vector);}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (status != 1) \{}
\DoxyCodeLine{            \textcolor{comment}{// Error!}}
\DoxyCodeLine{            std::cerr << \textcolor{stringliteral}{"{}Error at DestroyNodes, code: "{}} << status << std::endl;}
\DoxyCodeLine{        \}}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// destroy graph}}
\DoxyCodeLine{        status = \mbox{\hyperlink{a00458_ga645abacd11e1fa535f953344aaa77727}{DestroyGraph}}(graph);}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (status != 1) \{}
\DoxyCodeLine{            std::cerr << \textcolor{stringliteral}{"{}Error at DestroyGraph, code: "{}} << status << std::endl;}
\DoxyCodeLine{        \}}

\end{DoxyCodeInclude}


From here, please review the example at \mbox{\hyperlink{a00457_raytracer_teardown}{Raytracer teardown}} for instructions~\newline
 on how to free the remainder of the resources used by the graph --~\newline
 which are the (vector\texorpdfstring{$<$}{<}\mbox{\hyperlink{a01351}{HF\+::\+Geometry\+::\+Mesh\+Info}}\texorpdfstring{$>$}{>} $\ast$) and (\mbox{\hyperlink{}{HF\+::\+Raytracer\+::\+Embree\+Ray\+Tracer}} $\ast$) instances.

~\newline
 {\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} Load\+OBJ loaded mesh successfully into loaded\+\_\+obj at address 000002468EEBBEB0, code\+: 1}~\newline
{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} Create\+Raytracer created Embree\+Ray\+Tracer successfully into bvh at address 00000246849C59\+B0, code\+: 1}~\newline
{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} Node count\+: 594}~\newline
{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} \mbox{[}(-\/1, -\/6, 0, 0) (-\/1.\+5, -\/6.\+5, -\/0, 1) (-\/1.\+5, -\/6, -\/0, 2)\mbox{]}}~\newline


Definition at line \mbox{\hyperlink{a00404_source_l00022}{22}} of file \mbox{\hyperlink{a00404_source}{analysis\+\_\+\+C.\+cpp}}.



References \mbox{\hyperlink{a00008_source_l00467}{HF\+::\+Graph\+Generator\+::\+Graph\+Generator\+::\+Build\+Network()}}, \mbox{\hyperlink{a01551_aa70347b8a33b57c6f0a72d6eca4248d7}{HF\+::\+Spatial\+Structures\+::\+Graph\+::\+Nodes()}}, and \mbox{\hyperlink{a00176_source_l00032}{HF\+::\+Exceptions\+::\+OK}}.

Here is the call graph for this function\+:
% FIG 1
\mbox{\Hypertarget{a00454_gab9f58e3ecc686fa9bc34519b0faed734}\label{a00454_gab9f58e3ecc686fa9bc34519b0faed734}} 
\index{GraphGenerator@{GraphGenerator}!GenerateGraphObstacles@{GenerateGraphObstacles}}
\index{GenerateGraphObstacles@{GenerateGraphObstacles}!GraphGenerator@{GraphGenerator}}
\doxysubsubsection{\texorpdfstring{GenerateGraphObstacles()}{GenerateGraphObstacles()}}
{\footnotesize\ttfamily \mbox{\hyperlink{a00407_a91fa3b2bb3a7312ec39d74cc1fbc7bbe}{C\+\_\+\+INTERFACE}} Generate\+Graph\+Obstacles (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{a01411}{HF\+::\+Ray\+Tracer\+::\+Embree\+Ray\+Tracer}} $\ast$}]{ray\+\_\+tracer,  }\item[{const float $\ast$}]{start\+\_\+point,  }\item[{const float $\ast$}]{spacing,  }\item[{int}]{Max\+Nodes,  }\item[{float}]{Up\+Step,  }\item[{float}]{Up\+Slope,  }\item[{float}]{Down\+Step,  }\item[{float}]{Down\+Slope,  }\item[{int}]{max\+\_\+step\+\_\+connection,  }\item[{int}]{min\+\_\+connections,  }\item[{int}]{core\+\_\+count,  }\item[{const int $\ast$}]{obstacle\+\_\+ids,  }\item[{const int $\ast$}]{walkable\+\_\+ids,  }\item[{int}]{num\+\_\+obstacles,  }\item[{int}]{num\+\_\+walkables,  }\item[{\mbox{\hyperlink{a01551}{HF\+::\+Spatial\+Structures\+::\+Graph}} $\ast$$\ast$}]{out\+\_\+graph }\end{DoxyParamCaption})}



{\ttfamily \#include $<$\mbox{\hyperlink{a00407}{Cinterface/analysis\+\_\+\+C.\+h}}$>$}



Construct a graph by performing a breadth-\/first search of accessible space, seperating obstacles from walkable geometry. 


\begin{DoxyParams}{Parameters}
{\em ray\+\_\+tracer} & Raytracer containing the geometry to use for graph generation.\\
\hline
{\em start\+\_\+point} & The starting point for the graph generator to begin searching from. If this isn\textquotesingle{}t above solid ground, no nodes will be generated.\\
\hline
{\em spacing} & Space between nodes for each step of the search. Lower values will yield more nodes for a higher resolution graph.\\
\hline
{\em Max\+Nodes} & Stop generation after this many nodes. A value of -\/1 will generate an infinite amount of nodes. Note that the final node count may be greater than this value.\\
\hline
{\em Up\+Step} & Maximum height of a step the graph can traverse. Any steps higher this will be considered inaccessible.\\
\hline
{\em Up\+Slope} & Maximum upward slope the graph can traverse in degrees. Any slopes steeper than this will be considered inaccessible.\\
\hline
{\em Down\+Step} & Maximum step down the graph can traverse. Any steps steeper than this will be considered inaccessible.\\
\hline
{\em Down\+Slope} & The maximum downward slope the graph can traverse. Any slopes steeper than this will be considered inaccessible.\\
\hline
{\em max\+\_\+step\+\_\+connection} & Multiplier for number of children to generate for each node. Increasing this value will increase the number of edges in the graph, and as a result the amount of memory the algorithm requires.\\
\hline
{\em min\+\_\+connections} & The required out-\/degree for a node to be valid and stored. This must be greater than 0 and equal or less than the total connections created from max\+\_\+step\+\_\+connections. Default is 1. A value of 8 when max\+\_\+step\+\_\+connections=1 would be a grid.\\
\hline
{\em core\+\_\+count} & Number of cores to use. -\/1 will use all available cores, and 0 or 1 will run a serialized version of the algorithm.\\
\hline
{\em obstacle\+\_\+ids} & Array of geometry IDs to consider obstacles \\
\hline
{\em walkable\+\_\+ids} & Array of geometry IDs to consider as walkable surfaces \\
\hline
{\em num\+\_\+obstacles} & number of elements in {\ttfamily obstacle\+\_\+ids} \\
\hline
{\em num\+\_\+walkables} & number of elements in {\ttfamily walkable\+\_\+ids}\\
\hline
{\em out\+\_\+graph} & Address of a (\mbox{\hyperlink{a01551}{HF\+::\+Spatial\+Structures\+::\+Graph}} $\ast$); out\+\_\+graph will address heap-\/allocated memory to an initialized \mbox{\hyperlink{a01551}{HF\+::\+Spatial\+Structures\+::\+Graph}} on success.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{}{HF\+\_\+\+STATUS\+::\+OK}} if graph creation was successful. \mbox{\hyperlink{}{HF\+\_\+\+STATUS\+::\+NO\+\_\+\+GRAPH}} if \mbox{\hyperlink{a00454_ga2df84a732d1edfb70b7bd26d3282e129}{Generate\+Graph}} failed to generate a graph with more than a single node.
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{a00457_raytracer_setup}{Raytracer setup}} (how to create a BVH), \mbox{\hyperlink{a00457_raytracer_teardown}{Raytracer teardown}} (how to destroy a BVH)
\end{DoxySeeAlso}
You must {\bfseries{load an .obj file}} and {\bfseries{create a BVH}} first.~\newline
 Begin by reviewing the example at \mbox{\hyperlink{a00457_raytracer_setup}{Raytracer setup}} before proceeding below.

First, determine the {\bfseries{start point}}, {\bfseries{spacing of nodes for each axis}}, and {\bfseries{maximum nodes to generate}}.~\newline
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{// Define start point.}}
\DoxyCodeLine{        \textcolor{comment}{// These are Cartesian coordinates.}}
\DoxyCodeLine{        std::array<float, 3> start\_point \{ -\/1.0f, -\/6.0f, 1623.976928f \};}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// Define spacing.}}
\DoxyCodeLine{        \textcolor{comment}{// This is the spacing between nodes, with respect to each axis.}}
\DoxyCodeLine{        std::array<float, 3> spacing \{ 0.5f, 0.5f, 0.5f \};}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// Set max nodes.}}
\DoxyCodeLine{        \textcolor{keyword}{const} \textcolor{keywordtype}{int} max\_nodes = 500;}

\end{DoxyCodeInclude}


Then, determine the remainder of the values required by \mbox{\hyperlink{a00454_ga2df84a732d1edfb70b7bd26d3282e129}{Generate\+Graph}} before calling it.~\newline
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{// Generate graph.}}
\DoxyCodeLine{        \textcolor{comment}{// Notice that we pass the address of the graph pointer into GenerateGraph.}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// GenerateGraph will assign the deferenced address to a pointer that points}}
\DoxyCodeLine{        \textcolor{comment}{// to memory on the free store. We will call DestroyGraph to release the memory resources later on.}}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordtype}{float} up\_step = 1;                      \textcolor{comment}{// maximum height of a step the graph can traverse}}
\DoxyCodeLine{        \textcolor{keywordtype}{float} up\_slope = 1;                     \textcolor{comment}{// maximum upward slope the graph can traverse in degrees}}
\DoxyCodeLine{        \textcolor{keywordtype}{float} down\_step = 1;                    \textcolor{comment}{// maximum step down that the graph can traverse}}
\DoxyCodeLine{        \textcolor{keywordtype}{float} down\_slope = 1;                   \textcolor{comment}{// maximum downward slope that the graph can traverse}}
\DoxyCodeLine{        \textcolor{keywordtype}{int} maximum\_step\_connection = 1;        \textcolor{comment}{// multiplier for number of children to generate for each node}}
\DoxyCodeLine{        \textcolor{keywordtype}{int} core\_count = -\/1;                    \textcolor{comment}{// CPU core count, -\/1 uses all available cores on the machine}}
\DoxyCodeLine{}
\DoxyCodeLine{        \mbox{\hyperlink{a01551}{HF::SpatialStructures::Graph}}* graph = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{}
\DoxyCodeLine{        status = \mbox{\hyperlink{a00454_ga2df84a732d1edfb70b7bd26d3282e129}{GenerateGraph}}(bvh,}
\DoxyCodeLine{            start\_point.data(), spacing.data(), max\_nodes,}
\DoxyCodeLine{            up\_step, up\_slope,}
\DoxyCodeLine{            down\_step, down\_slope,}
\DoxyCodeLine{            maximum\_step\_connection,}
\DoxyCodeLine{            core\_count,}
\DoxyCodeLine{            \&graph);}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (status != 1) \{}
\DoxyCodeLine{            \textcolor{comment}{// Error!}}
\DoxyCodeLine{            std::cerr << \textcolor{stringliteral}{"{}Error at GenerateGraph, code: "{}} << status << std::endl;}
\DoxyCodeLine{        \}}

\end{DoxyCodeInclude}


{\bfseries{Very important!}} {\bfseries{Compress the graph}} after generating a graph or adding edges.~\newline
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{// Always compress the graph after generating a graph/adding new edges}}
\DoxyCodeLine{        status = \mbox{\hyperlink{a00458_gab7ecc1be5c746ed3f99ab7494316c65d}{Compress}}(graph);}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (status != 1) \{}
\DoxyCodeLine{            \textcolor{comment}{// Error!}}
\DoxyCodeLine{            std::cerr << \textcolor{stringliteral}{"{}Error at Compress, code: "{}} << status << std::endl;}
\DoxyCodeLine{        \}}

\end{DoxyCodeInclude}


To output the graph to the console, we must {\bfseries{retrieve its nodes}}.~\newline
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{// Get all nodes from graph first (the container of nodes)}}
\DoxyCodeLine{        \textcolor{comment}{// The address of the local variable node\_vector will be passed to GetAllNodesFromGraph;}}
\DoxyCodeLine{        \textcolor{comment}{// it will be dereferenced inside that function and assigned memory via operator new.}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// We will have to call DestroyNodes on node\_vector to properly release this memory.}}
\DoxyCodeLine{        \textcolor{comment}{// node\_vector\_data points to the internal buffer that resides within *(node\_vector).}}
\DoxyCodeLine{        \textcolor{comment}{//}}
\DoxyCodeLine{        \textcolor{comment}{// When we call DestroyNodes, node\_vector\_data's memory will also be released.}}
\DoxyCodeLine{        std::vector<HF::SpatialStructures::Node>* node\_vector = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{        \mbox{\hyperlink{a02071}{HF::SpatialStructures::Node}}* node\_vector\_data = \textcolor{keyword}{nullptr};}
\DoxyCodeLine{}
\DoxyCodeLine{        status = \mbox{\hyperlink{a00458_ga0cc5b82caab046c65a201e4e7be5e9d4}{GetAllNodesFromGraph}}(graph, \&node\_vector, \&node\_vector\_data);}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (status != 1) \{}
\DoxyCodeLine{            \textcolor{comment}{// Error!}}
\DoxyCodeLine{            std::cerr << \textcolor{stringliteral}{"{}Error at GetAllNodesFromGraph, code: "{}} << status << std::endl;}
\DoxyCodeLine{        \}}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// Get size of node vector}}
\DoxyCodeLine{        \textcolor{keywordtype}{int} node\_vector\_size = -\/1;}
\DoxyCodeLine{        status = \mbox{\hyperlink{a00458_gac17c1fc05e6bf6900bac8689b7619bfb}{GetSizeOfNodeVector}}(node\_vector, \&node\_vector\_size);}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (status != 1) \{}
\DoxyCodeLine{            \textcolor{comment}{// Error!}}
\DoxyCodeLine{            std::cerr << \textcolor{stringliteral}{"{}Error at GetSizeOfNodeVector, code: "{}} << status << std::endl;}
\DoxyCodeLine{        \}}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// Print number of nodes in the graph}}
\DoxyCodeLine{        std::cout << \textcolor{stringliteral}{"{}Node count: "{}} << node\_vector\_size << std::endl;}

\end{DoxyCodeInclude}


We are now ready to {\bfseries{output}} the generated graph to the {\bfseries{console}}.~\newline
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{        \textcolor{comment}{// Output 3 of the nodes within *node\_vector.}}
\DoxyCodeLine{        std::cout << \textcolor{stringliteral}{"{}["{}};}
\DoxyCodeLine{        \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 3; i++) \{}
\DoxyCodeLine{            \textcolor{keyword}{auto} n = (*node\_vector)[i];}
\DoxyCodeLine{            std::cout << \textcolor{stringliteral}{"{}("{}}}
\DoxyCodeLine{                << n.x << \textcolor{stringliteral}{"{}, "{}} << n.y << \textcolor{stringliteral}{"{}, "{}} << n.z << \textcolor{stringliteral}{"{}, "{}}}
\DoxyCodeLine{                << n.id << \textcolor{stringliteral}{"{})"{}};}
\DoxyCodeLine{}
\DoxyCodeLine{            \textcolor{keywordflow}{if} (i < 2) \{}
\DoxyCodeLine{                std::cout << \textcolor{stringliteral}{"{} "{}};}
\DoxyCodeLine{            \}}
\DoxyCodeLine{        \}}
\DoxyCodeLine{        std::cout << \textcolor{stringliteral}{"{}]"{}} << std::endl;}

\end{DoxyCodeInclude}


When we are finished, we must destroy {\bfseries{node\+\_\+vector}} and {\bfseries{graph}}.~\newline
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// destroy vector<Node>}}
\DoxyCodeLine{        status = \mbox{\hyperlink{a00458_ga87e9b9ecfc5293712d75f3cb8c992c77}{DestroyNodes}}(node\_vector);}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (status != 1) \{}
\DoxyCodeLine{            \textcolor{comment}{// Error!}}
\DoxyCodeLine{            std::cerr << \textcolor{stringliteral}{"{}Error at DestroyNodes, code: "{}} << status << std::endl;}
\DoxyCodeLine{        \}}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{comment}{// destroy graph}}
\DoxyCodeLine{        status = \mbox{\hyperlink{a00458_ga645abacd11e1fa535f953344aaa77727}{DestroyGraph}}(graph);}
\DoxyCodeLine{}
\DoxyCodeLine{        \textcolor{keywordflow}{if} (status != 1) \{}
\DoxyCodeLine{            std::cerr << \textcolor{stringliteral}{"{}Error at DestroyGraph, code: "{}} << status << std::endl;}
\DoxyCodeLine{        \}}

\end{DoxyCodeInclude}


From here, please review the example at \mbox{\hyperlink{a00457_raytracer_teardown}{Raytracer teardown}} for instructions~\newline
 on how to free the remainder of the resources used by the graph --~\newline
 which are the (vector\texorpdfstring{$<$}{<}\mbox{\hyperlink{a01351}{HF\+::\+Geometry\+::\+Mesh\+Info}}\texorpdfstring{$>$}{>} $\ast$) and (\mbox{\hyperlink{}{HF\+::\+Raytracer\+::\+Embree\+Ray\+Tracer}} $\ast$) instances.

~\newline
 {\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} Load\+OBJ loaded mesh successfully into loaded\+\_\+obj at address 000002468EEBBEB0, code\+: 1}~\newline
{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} Create\+Raytracer created Embree\+Ray\+Tracer successfully into bvh at address 00000246849C59\+B0, code\+: 1}~\newline
{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} Node count\+: 594}~\newline
{\ttfamily \texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>}\texorpdfstring{$>$}{>} \mbox{[}(-\/1, -\/6, 0, 0) (-\/1.\+5, -\/6.\+5, -\/0, 1) (-\/1.\+5, -\/6, -\/0, 2)\mbox{]}}~\newline


Definition at line \mbox{\hyperlink{a00404_source_l00062}{62}} of file \mbox{\hyperlink{a00404_source}{analysis\+\_\+\+C.\+cpp}}.



References \mbox{\hyperlink{a00008_source_l00467}{HF\+::\+Graph\+Generator\+::\+Graph\+Generator\+::\+Build\+Network()}}, \mbox{\hyperlink{a00404_source_l00015}{Map\+To\+Vector()}}, \mbox{\hyperlink{a01551_aa70347b8a33b57c6f0a72d6eca4248d7}{HF\+::\+Spatial\+Structures\+::\+Graph\+::\+Nodes()}}, and \mbox{\hyperlink{a00176_source_l00032}{HF\+::\+Exceptions\+::\+OK}}.

Here is the call graph for this function\+:
% FIG 2
